<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Border Transition Demo</title>
    <style>
      :root {
        --demo-red: #ff0000;
        --demo-blue: #0000ff;
        --demo-green: #00ff00;
        --demo-orange: #ffa500;
      }

      body {
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        font-family: Arial, sans-serif;
        background: #f5f5f5;
      }

      .demo-section {
        margin: 30px 0;
        padding: 30px;
        background: white;
        border: 1px solid #ddd;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .controls-area {
        padding: 20px;
        padding-bottom: 10px;
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
      }

      .transition-area {
        display: grid;
        margin: 20px 0;
        grid-template-columns: 1fr 1fr;
        align-items: start;
        gap: 0;
        background: white;
        border: 2px solid #dee2e6;
        border-radius: 8px;
        overflow: hidden;
      }

      .transition-column {
        display: flex;
        min-height: 200px;
        padding: 25px;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        background: #fafafa;
      }

      .transition-column:first-child {
        background: #f8f9fa;
        border-right: 2px solid #dee2e6;
      }

      .transition-column h3 {
        margin: 0 0 5px 0;
        color: #495057;
        font-weight: 600;
        font-size: 18px;
        text-align: center;
      }

      .transition-column .subtitle {
        margin: 0 0 5px 0;
        color: #6c757d;
        font-style: italic;
        font-weight: 400;
        font-size: 12px;
        text-align: center;
      }

      .transition-box {
        display: flex;
        width: 150px;
        height: 150px;
        align-items: center;
        justify-content: center;
        color: #333;
        font-weight: bold;
        font-size: 14px;
        text-align: center;
        background: #f0f0f0;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      #userAgentBox {
        transition: border 1s ease;
      }

      .selector-fieldset {
        margin: 15px 0;
        padding: 15px;
        background: #fafafa;
        border: 2px solid #ddd;
        border-radius: 8px;
      }

      .selectors-container {
        display: grid;
        margin: 15px 0;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }

      .selector-fieldset legend {
        padding: 0 10px;
        color: #555;
        font-weight: bold;
      }

      .option-category {
        margin: 10px 0;
      }

      .option-category h4 {
        margin: 8px 0 5px 0;
        color: #666;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .option-grid {
        display: flex;
        margin-bottom: 10px;
        flex-wrap: wrap;
        gap: 8px;
      }

      .option-rect {
        position: relative;
        width: 40px;
        height: 30px;
        background: #f8f8f8;
        border-radius: 4px;
        transition: all 0.2s ease;
        cursor: pointer;
      }

      .option-rect.selected {
        box-shadow: 0 0 0 2px #007acc;
      }

      .option-rect[title] {
        position: relative;
      }

      .controls {
        display: flex;
        margin: 15px 0;
        flex-wrap: wrap;
        align-items: center;
        gap: 15px;
      }

      select,
      button,
      input {
        padding: 10px 15px;
        font-size: 14px;
        border: 1px solid #ccc;
        border-radius: 6px;
      }

      select {
        min-width: 150px;
      }

      button {
        color: white;
        font-weight: bold;
        background: #007acc;
        border: none;
        transition: background 0.2s;
        cursor: pointer;
      }

      button:hover {
        background: #005a9e;
      }

      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .duration-control {
        margin: 15px 0;
        padding: 10px;
        background: #f0f8ff;
        border: 1px solid #b3d9ff;
        border-radius: 6px;
      }

      .duration-control input[type="range"] {
        width: 180px;
      }

      .duration-control label {
        display: flex;
        margin: 0;
        align-items: center;
        gap: 8px;
        font-size: 14px;
      }

      label {
        margin-right: 10px;
        font-weight: bold;
      }

      h1 {
        margin-bottom: 30px;
        color: #333;
        text-align: center;
      }

      h2 {
        margin-top: 0;
        padding-bottom: 10px;
        color: #333;
        border-bottom: 3px solid #007acc;
      }

      .section-description {
        margin-bottom: 20px;
        color: #666;
        font-size: 16px;
        line-height: 1.4;
      }

      .preview-boxes {
        display: flex;
        margin: 15px 0;
        flex-wrap: wrap;
        align-items: center;
        gap: 15px;
      }

      .preview-box {
        display: flex;
        width: 60px;
        height: 60px;
        align-items: center;
        justify-content: center;
        color: #333;
        font-weight: bold;
        font-size: 10px;
        background: #f8f8f8;
        border-radius: 6px;
      }

      .arrow-container {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .invert-button {
        position: absolute;
        top: 25px;
        z-index: 10;
        padding: 4px 8px;
        color: #007acc;
        font-weight: bold;
        font-size: 11px;
        background: white;
        border: 1px solid #007acc;
        border-radius: 0px;
        transition: all 0.2s ease;
        cursor: pointer;
      }

      .invert-button:hover {
        color: white;
        background: #007acc;
      }

      details {
        margin: 15px 0;
        padding: 10px;
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
      }

      summary {
        padding: 5px 0;
        color: #555;
        font-weight: bold;
        cursor: pointer;
        user-select: none;
      }

      summary:hover {
        color: #007acc;
      }

      details[open] summary {
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 1px solid #e9ecef;
      }
    </style>
  </head>
  <body>
    <h1>Border Transition Demo - User Agent vs Navi</h1>

    <!-- Main Border Transition Demo -->
    <div class="demo-section">
      <h2>Border Transition Testing</h2>
      <p class="section-description">
        Configure source and destination borders (styles, widths, colors), then
        watch the transition happen in the isolated box below. Supports
        different border styles: solid, dashed, dotted, double, groove, ridge,
        inset, outset, and various widths and colors.
      </p>

      <!-- Controls Area -->
      <div class="controls-area">
        <h3 style="margin-top: 0; color: #555">Configuration</h3>

        <div class="duration-control">
          <label>
            Duration:
            <input
              type="range"
              id="duration"
              min="100"
              max="3000"
              value="1000"
              step="100"
            />
            <span id="durationValue">1000ms</span>
          </label>
        </div>

        <div class="selectors-container">
          <fieldset class="selector-fieldset">
            <legend>From Border</legend>
            <div id="fromSelector"></div>
          </fieldset>

          <fieldset class="selector-fieldset">
            <legend>To Border</legend>
            <div id="toSelector"></div>
          </fieldset>
        </div>

        <div
          style="
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: -15px;
            margin-bottom: 5px;
          "
        >
          <button id="startTransition">Start Transition</button>
          <div style="display: flex; align-items: center; gap: 10px">
            <span style="font-weight: bold">Preview:</span>
            <div class="preview-box" id="fromPreview">FROM</div>
            <div class="arrow-container">
              <button
                class="invert-button"
                id="invertButton"
                title="Swap FROM and TO"
              >
                ↔
              </button>
              <span style="font-size: 20px; color: #007acc">→</span>
            </div>
            <div class="preview-box" id="toPreview">TO</div>
          </div>
        </div>

        <details>
          <summary>Debugging Options</summary>
          <label style="display: flex; align-items: center; gap: 8px">
            <input type="checkbox" id="pauseBreakpoints" />
            <span>Pause at 50% for debugging</span>
          </label>
          <button
            id="resumeTransitions"
            style="margin-top: 10px; padding: 8px 15px"
            disabled
          >
            Resume Paused Transitions
          </button>
        </details>
      </div>

      <!-- Transition Area -->
      <div class="transition-area">
        <div class="transition-column">
          <h3>User Agent</h3>
          <div class="subtitle">CSS transition: border</div>
          <div class="transition-box" id="userAgentBox">
            USER AGENT<br />BOX
          </div>
        </div>
        <div class="transition-column">
          <h3>Navi</h3>
          <div class="subtitle">Custom transition system</div>
          <div class="transition-box" id="naviBox">NAVI<br />BOX</div>
        </div>
      </div>
    </div>

    <script type="module">
      // Create a border transition function similar to createBackgroundTransition
      const createBorderTransition = (element, to, options = {}) => {
        const fromBorder = options.from || getComputedStyle(element).border;
        const duration = options.duration || 300;
        const pauseBreakpoints = options.pauseBreakpoints || [];

        // Set initial border
        element.style.border = fromBorder;

        return new Promise((resolve) => {
          let pauseTimeout;

          const transition = {
            play: () => {
              // Check for pause breakpoints
              if (pauseBreakpoints.includes(0.5)) {
                // Pause at 50%
                pauseTimeout = setTimeout(() => {
                  element.style.animationPlayState = "paused";

                  if (options.onPause) options.onPause();

                  // Set up resume function
                  window.resumeTransitions = () => {
                    element.style.animationPlayState = "running";

                    if (options.onResume) options.onResume();
                  };
                }, duration / 2);
              }

              requestAnimationFrame(() => {
                // Start CSS transition
                element.style.border = to;

                // Listen for transition end
                const onTransitionEnd = (event) => {
                  if (
                    event.target === element &&
                    event.propertyName.includes("border")
                  ) {
                    element.removeEventListener(
                      "transitionend",
                      onTransitionEnd,
                    );
                    clearTimeout(pauseTimeout);
                    if (options.onFinish) options.onFinish();
                    resolve(transition);
                  }
                };

                element.addEventListener("transitionend", onTransitionEnd);

                // Fallback timeout
                setTimeout(() => {
                  element.removeEventListener("transitionend", onTransitionEnd);
                  clearTimeout(pauseTimeout);
                  if (options.onFinish) options.onFinish();
                  resolve(transition);
                }, duration + 100);
              });
            },
            cancel: () => {
              clearTimeout(pauseTimeout);
              element.style.border = "";
            },
          };

          resolve(transition);
        });
      };

      // LocalStorage utilities
      const STORAGE_KEY = "border-transition-demo";

      function saveToStorage(data) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        } catch (e) {
          console.warn("Failed to save to localStorage:", e);
        }
      }

      function loadFromStorage() {
        try {
          const data = localStorage.getItem(STORAGE_KEY);
          return data ? JSON.parse(data) : null;
        } catch (e) {
          console.warn("Failed to load from localStorage:", e);
          return null;
        }
      }

      function getStoredState() {
        const stored = loadFromStorage();
        return {
          selectedFrom: stored?.selectedFrom || "none",
          selectedTo: stored?.selectedTo || "2px solid #0000ff",
          duration: stored?.duration || 1000,
          pauseBreakpoints: stored?.pauseBreakpoints || false,
        };
      }

      function saveState() {
        saveToStorage({
          selectedFrom,
          selectedTo,
          duration: getDuration(),
          pauseBreakpoints: getPauseBreakpoints(),
        });
      }

      // Border options organized by category
      const borderCategories = {
        Special: [
          {
            value: "none",
            label: "None",
            border: "none",
            defaultFrom: true,
          },
          {
            value: "0px solid transparent",
            label: "Transparent",
            border: "2px solid transparent",
          },
        ],
        Solid: [
          {
            value: "1px solid #ff0000",
            label: "Red Thin",
            border: "1px solid #ff0000",
          },
          {
            value: "2px solid #0000ff",
            label: "Blue Medium",
            border: "2px solid #0000ff",
            defaultTo: true,
          },
          {
            value: "4px solid #00ff00",
            label: "Green Thick",
            border: "4px solid #00ff00",
          },
          {
            value: "8px solid #000000",
            label: "Black Ultra",
            border: "8px solid #000000",
          },
          {
            value: "15px solid #ff6600",
            label: "Orange Huge",
            border: "15px solid #ff6600",
          },
          {
            value: "20px solid #9900cc",
            label: "Purple Max",
            border: "20px solid #9900cc",
          },
        ],
        Special_Styles: [
          {
            value: "3px dashed #0000ff",
            label: "Blue Dash",
            border: "3px dashed #0000ff",
          },
          {
            value: "3px dotted #00ff00",
            label: "Green Dots",
            border: "3px dotted #00ff00",
          },
          {
            value: "4px double #ff0000",
            label: "Red Double",
            border: "4px double #ff0000",
          },
          {
            value: "4px groove #888888",
            label: "Gray Groove",
            border: "4px groove #888888",
          },
          {
            value: "4px ridge #888888",
            label: "Gray Ridge",
            border: "4px ridge #888888",
          },
          {
            value: "4px inset #888888",
            label: "Gray Inset",
            border: "4px inset #888888",
          },
          {
            value: "4px outset #888888",
            label: "Gray Outset",
            border: "4px outset #888888",
          },
        ],
      };

      // Initialize from localStorage or defaults
      const initialState = getStoredState();
      let selectedFrom = initialState.selectedFrom;
      let selectedTo = initialState.selectedTo;

      function createOptionRect(option) {
        const rect = document.createElement("div");
        rect.className = "option-rect";
        if (option.border === "none") {
          rect.style.border = "none";
          rect.style.background = "#e9ecef";
          rect.style.color = "#6c757d";
          rect.style.fontSize = "8px";
          rect.style.fontWeight = "bold";
          rect.textContent = "NONE";
        } else if (option.value === "0px solid transparent") {
          rect.style.border = option.border;
          rect.style.background = "#fff3cd";
          rect.style.color = "#856404";
          rect.style.fontSize = "7px";
          rect.style.fontWeight = "bold";
          rect.textContent = "TRANSP";
        } else {
          rect.style.border = option.border;
        }
        rect.title = option.label;
        rect.dataset.value = option.value;
        return rect;
      }

      function createCategorySelector(containerId, selectedValue, onSelect) {
        const container = document.getElementById(containerId);
        container.innerHTML = "";

        Object.entries(borderCategories).forEach(([categoryName, options]) => {
          const categoryDiv = document.createElement("div");
          categoryDiv.className = "option-category";

          const header = document.createElement("h4");
          header.textContent = categoryName.replace(/_/g, " ");
          categoryDiv.appendChild(header);

          const grid = document.createElement("div");
          grid.className = "option-grid";

          options.forEach((option) => {
            const rect = createOptionRect(option);
            if (option.value === selectedValue) {
              rect.classList.add("selected");
            }

            rect.addEventListener("click", () => {
              // Remove selection from all rects in this container
              container
                .querySelectorAll(".option-rect.selected")
                .forEach((r) => r.classList.remove("selected"));
              // Add selection to clicked rect
              rect.classList.add("selected");
              onSelect(option.value);
            });

            grid.appendChild(rect);
          });

          categoryDiv.appendChild(grid);
          container.appendChild(categoryDiv);
        });
      }

      let currentTransitions = [];

      // Duration slider handlers
      function setupDurationSlider(sliderId, valueId) {
        const slider = document.getElementById(sliderId);
        const valueDisplay = document.getElementById(valueId);

        // Set initial value from localStorage
        slider.value = initialState.duration;
        valueDisplay.textContent = `${initialState.duration}ms`;

        slider.addEventListener("input", (e) => {
          valueDisplay.textContent = `${e.target.value}ms`;
          saveState();
        });
        return () => parseInt(slider.value);
      }

      const getDuration = setupDurationSlider("duration", "durationValue");

      // Pause breakpoints checkbox handler
      function setupPauseBreakpoints() {
        const checkbox = document.getElementById("pauseBreakpoints");
        const resumeButton = document.getElementById("resumeTransitions");

        // Set initial value from localStorage
        checkbox.checked = initialState.pauseBreakpoints;

        checkbox.addEventListener("change", () => {
          saveState();
        });

        // Resume button handler
        resumeButton.addEventListener("click", () => {
          if (typeof window.resumeTransitions === "function") {
            window.resumeTransitions();
            resumeButton.disabled = true;
          }
        });

        return () => checkbox.checked;
      }

      const getPauseBreakpoints = setupPauseBreakpoints();

      function stopCurrentTransitions() {
        currentTransitions.forEach((t) => t.cancel && t.cancel());
        currentTransitions = [];
      }

      // Main Border Transition Section
      const fromPreview = document.getElementById("fromPreview");
      const toPreview = document.getElementById("toPreview");

      // Create visual selectors
      createCategorySelector("fromSelector", selectedFrom, (value) => {
        selectedFrom = value;
        updatePreviewBoxes();
        saveState();
      });

      createCategorySelector("toSelector", selectedTo, (value) => {
        selectedTo = value;
        updatePreviewBoxes();
        saveState();
      });

      function updatePreviewBoxes() {
        function applyBorder(element, value) {
          if (value === "none") {
            element.style.border = "none";
          } else {
            element.style.border = value;
          }
        }

        applyBorder(fromPreview, selectedFrom);
        applyBorder(toPreview, selectedTo);
        applyBorder(document.getElementById("userAgentBox"), selectedFrom);
        applyBorder(document.getElementById("naviBox"), selectedFrom);
      }

      document
        .getElementById("startTransition")
        .addEventListener("click", async () => {
          stopCurrentTransitions();

          const userAgentBox = document.getElementById("userAgentBox");
          const naviBox = document.getElementById("naviBox");

          // Reset both boxes to starting state
          if (selectedFrom === "none") {
            userAgentBox.style.border = "none";
            naviBox.style.border = "none";
          } else {
            userAgentBox.style.border = selectedFrom;
            naviBox.style.border = selectedFrom;
          }

          // Update user agent transition duration to match
          const duration = getDuration();
          userAgentBox.style.transitionDuration = `${duration}ms`;

          const pauseBreakpoints = getPauseBreakpoints() ? [0.5] : [];
          const resumeButton = document.getElementById("resumeTransitions");

          // Start user agent transition (simple CSS change)
          setTimeout(() => {
            if (selectedTo === "none") {
              userAgentBox.style.border = "none";
            } else {
              userAgentBox.style.border = selectedTo;
            }
          }, 10);

          // Start navi custom transition
          const transition = await createBorderTransition(
            naviBox,
            selectedTo === "none" ? "none" : selectedTo,
            {
              from: selectedFrom === "none" ? "none" : selectedFrom,
              duration,
              pauseBreakpoints,
              onPause: () => {
                resumeButton.disabled = false;
              },
              onFinish: () => {
                resumeButton.disabled = true;
              },
            },
          );

          currentTransitions.push(transition);
          transition.play();
        });

      // Invert button handler
      document.getElementById("invertButton").addEventListener("click", () => {
        // Swap selectedFrom and selectedTo
        const temp = selectedFrom;
        selectedFrom = selectedTo;
        selectedTo = temp;

        // Update the UI to reflect the change
        updatePreviewBoxes();
        saveState();

        // Update the selectors to show the new selection
        // Force update both selectors
        document.querySelectorAll(".option-rect").forEach((rect) => {
          rect.classList.remove("selected");
          if (
            rect.dataset.value === selectedFrom &&
            rect.closest("#fromSelector")
          ) {
            rect.classList.add("selected");
          }
          if (
            rect.dataset.value === selectedTo &&
            rect.closest("#toSelector")
          ) {
            rect.classList.add("selected");
          }
        });
      });

      // Initialize
      updatePreviewBoxes();
    </script>
  </body>
</html>
