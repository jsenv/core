# [mostSpecificRoute should prefer literal over parameterized routes](../../route_document_url_sync.test.js)

```js
try {
  const walkEnabledSignal = stateSignal(false, {
    id: "mostSpecificWalkEnabled",
    type: "boolean",
  });
  const walkMinuteSignal = stateSignal(30, {
    id: "mostSpecificWalkMinute",
    type: "number",
  });
  const isochroneTabSignal = stateSignal("compare", {
    id: "mostSpecificIsochroneTab",
    type: "string",
  });
  const isochroneLongitudeSignal = stateSignal(2.3522, {
    id: "mostSpecificIsochroneLongitude",
    type: "number",
  });

  // These two routes should demonstrate the specificity issue:
  // - ISOCHRONE_ROUTE: `/map/isochrone/:tab` (generic with :tab parameter)
  // - ISOCHRONE_COMPARE_ROUTE: `/map/isochrone/compare` (literal with "compare")
  // ISOCHRONE_COMPARE_ROUTE should be considered more specific
  const { ISOCHRONE_ROUTE, ISOCHRONE_COMPARE_ROUTE } = setupRoutes({
    ISOCHRONE_ROUTE: `/map/isochrone/:tab=${isochroneTabSignal}/?iso_lon=${isochroneLongitudeSignal}`,
    ISOCHRONE_COMPARE_ROUTE: `/map/isochrone/compare?walk=${walkEnabledSignal}&walk_minute=${walkMinuteSignal}`,
  });

  // Navigate to the compare route
  updateRoutes(`${baseUrl}/map/isochrone/compare`);

  const routeMatching = {
    isochrone_matches: ISOCHRONE_ROUTE.matching,
    compare_matches: ISOCHRONE_COMPARE_ROUTE.matching,
  };

  // Calculate segments the current way (which is problematic)
  const isochroneSegments = ISOCHRONE_ROUTE.pattern
    .split("/")
    .filter((s) => s !== "").length;
  const compareSegments = ISOCHRONE_COMPARE_ROUTE.pattern
    .split("/")
    .filter((s) => s !== "").length;

  // Mock browser integration to track navigation calls
  const navToCalls = [];
  const mockBrowserIntegration = {
    navTo: (url) => {
      navToCalls.push(url);
      updateRoutes(url);
      return Promise.resolve();
    },
  };
  setBrowserIntegration(mockBrowserIntegration);

  // Trigger a replaceParams to see which route is considered most specific
  walkEnabledSignal.value = true;

  return {
    route_patterns: {
      isochrone: ISOCHRONE_ROUTE.pattern,
      compare: ISOCHRONE_COMPARE_ROUTE.pattern,
    },
    segment_counts: {
      isochrone: isochroneSegments,
      compare: compareSegments,
    },
    route_matching: routeMatching,
    nav_to_calls: navToCalls,
    most_specific_url_used:
      navToCalls.length > 0 ? navToCalls[navToCalls.length - 1] : "none",

    // Analysis:
    expected_most_specific_url: "/map/isochrone/compare?walk", // Should navigate to compare route with walk param
    actual_segments_comparison: {
      problem: `Current code counts segments: isochrone=${isochroneSegments}, compare=${compareSegments}`,
      issue:
        "The code might incorrectly consider ISOCHRONE_ROUTE more specific due to query params",
    },
  };
} finally {
  clearAllRoutes();
  globalSignalRegistry.clear();
}
```

```js
{
  "route_patterns": {
    "isochrone": "/map/isochrone/:tab/?iso_lon",
    "compare": "/map/isochrone/compare?walk&walk_minute"
  },
  "segment_counts": {
    "isochrone": 4,
    "compare": 3
  },
  "route_matching": {
    "isochrone_matches": true,
    "compare_matches": true
  },
  "nav_to_calls": [
    "http://127.0.0.1/map/isochrone?walk"
  ],
  "most_specific_url_used": "http://127.0.0.1/map/isochrone?walk",
  "expected_most_specific_url": "/map/isochrone/compare?walk",
  "actual_segments_comparison": {
    "problem": "Current code counts segments: isochrone=4, compare=3",
    "issue": "The code might incorrectly consider ISOCHRONE_ROUTE more specific due to query params"
  }
}
```

---

<sub>
  Generated by <a href="https://github.com/jsenv/core/tree/main/packages/tooling/snapshot">@jsenv/snapshot</a>
</sub>
