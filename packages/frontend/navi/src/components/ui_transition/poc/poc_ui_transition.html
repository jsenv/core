<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Test Smooth Resize Transition</title>
    <style>
      body {
        margin: 40px;
        font-family: Arial, sans-serif;
        background: #f5f5f5;
      }

      .controls {
        display: flex;
        margin-bottom: 40px;
        gap: 10px;
      }

      button {
        padding: 10px 20px;
        color: white;
        font-size: 14px;
        background: #007acc;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      button:hover {
        background: #005a99;
      }

      button.active {
        background: #ff6b35;
      }

      /* État désactivé pendant les transitions */
      button:disabled {
        color: #999;
        background: #ccc;
        opacity: 0.6;
        cursor: not-allowed;
      }

      .rectangle.disabled {
        opacity: 0.5;
        filter: grayscale(50%);
        cursor: not-allowed;
      }

      .controls-disabled {
        opacity: 0.6;
        pointer-events: none;
      }

      /* Contrôles dans le DOM de base */
      .controls-container {
        display: flex;
        margin-top: 15px;
        flex-direction: column;
        gap: 15px;
      }

      .settings-controls {
        display: flex;
        padding: 10px;
        flex-wrap: wrap;
        align-items: center;
        gap: 15px;
        background: #f0f0f0;
        border-radius: 4px;
      }

      .action-controls {
        display: flex;
        padding: 10px;
        align-items: center;
        gap: 10px;
        background: #e8f4f8;
        border-radius: 4px;
      }

      .transition-container.empty {
        display: flex;
        width: 300px;
        height: 80px;
        align-items: center;
        justify-content: center;
        color: #999;
        font-style: italic;
      }

      .duration-control {
        display: flex;
        align-items: center;
        gap: 8px;
        color: #333;
        font-size: 14px;
      }

      .duration-control input[type="range"] {
        width: 120px;
      }

      .duration-control span:last-child {
        min-width: 50px;
        font-weight: bold;
      }

      .alignment-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        color: #333;
        font-size: 14px;
      }

      .align-control {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      /* Rectangles visibles pour cliquer */
      .rectangles-container {
        display: flex;
        margin-bottom: 20px;
        margin-bottom: 20px;
        flex-direction: column;
        flex-wrap: wrap;
        gap: 20px;
      }

      .rectangles-container h3 {
        margin: 0 0 10px 0;
        padding-bottom: 5px;
        color: #333;
        font-size: 16px;
        border-bottom: 1px solid #ddd;
      }

      .content-items,
      .phase-items {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .rectangle,
      .phase {
        display: flex;
        box-sizing: border-box;
        padding: 20px;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border: 2px solid #ddd;
        border-radius: 8px;
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
        cursor: pointer;
      }

      .phase {
        background: #f0f8ff;
        border-color: #007acc;
      }

      .phase.error-phase {
        background: #fff5f5;
        border-color: #dc3545;
      }

      /* Add spin animation for loading */
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .rectangle[data-state="a"] {
        color: white;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }

      .rectangle[data-state="b"] {
        color: white;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }

      .rectangle[data-state="c"] {
        color: white;
        background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
      }

      .rectangle h3 {
        margin: 0 0 10px 0;
        font-size: 18px;
      }

      .rectangle p {
        margin: 0;
        font-size: 14px;
        text-align: center;
        line-height: 1.4;
      }

      /* Zone de transition */
      .transition-zone {
        margin-top: 10px;
      }

      .transition-zone h4 {
        margin-top: 10px;
        margin-bottom: 20px;
        color: #333;
      }

      /* Boîte de visualisation pour centrer la zone de transition */
      .transition-viewport {
        position: relative;
        display: flex;
        width: 350px;
        height: 250px;
        margin: 20px 0;
        align-items: center;
        justify-content: center;
        background: #fafafa;
        border: 3px solid #007acc;
        border-radius: 8px;
      }

      .transition-viewport::before {
        position: absolute;
        top: -8px;
        left: 10px;
        padding: 0 8px;
        color: #007acc;
        font-weight: bold;
        font-size: 12px;
        background: #fafafa;
        content: "Zone de visualisation 350x250";
      }

      /* Ghost debug dans la viewport (position absolue pour ne pas impacter le layout) */
      .debug-ghost {
        position: absolute;
        top: 50%;
        left: 50%;
        z-index: 10;
        border-radius: 4px;
        box-shadow: 0 0 0 3px #ff6b35;
        opacity: 0.3;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }

      .content h3 {
        margin: 0 0 10px 0;
        font-size: 18px;
      }

      .content p {
        margin: 0;
        font-size: 14px;
        text-align: center;
        line-height: 1.4;
      }

      /* Debug info */
      .debug-info {
        margin-top: 30px;
        padding: 15px;
        font-size: 12px;
        font-family: monospace;
        background: #f9f9f9;
        border-radius: 4px;
      }

      .content {
        box-sizing: border-box;
        padding: 20px;
        border-radius: 4px;
      }

      .content.state-empty {
        color: #666;
        font-style: italic;
      }

      .debug-info div {
        margin-bottom: 5px;
      }
    </style>
  </head>
  <body>
    <h1>Test de Transition smooth</h1>

    <!-- Rectangles visibles pour cliquer -->
    <div class="rectangles-container">
      <details open>
        <summary>Content</summary>

        <div class="content-items">
          <div style="width: 100px; height: 100px">
            <div class="rectangle" data-state="a" id="rect-a">
              <h3>A</h3>
              <p>Du texte yep</p>
            </div>
          </div>

          <div style="width: 300px; height: 150px">
            <div class="rectangle" data-state="b" id="rect-b">
              <h3>B</h3>
              <p>
                Rectangle plus grand avec plus de contenu. Ce texte est plus
                long pour voir comment le contenu s'adapte dans un espace plus
                grand. La transition doit être fluide.
              </p>
            </div>
          </div>

          <div style="width: 100px; height: 200px">
            <div class="rectangle" data-state="c" id="rect-c">
              <h3>C</h3>
              <p>Format portrait</p>
            </div>
          </div>
        </div>
      </details>

      <details>
        <summary>Content phase</summary>
        <div class="phase-items">
          <div
            class="phase loading-phase"
            data-phase="loading"
            id="loading"
            style="width: 100%; height: 100%"
          >
            <div
              style="
                display: flex;
                align-items: center;
                gap: 10px;
                color: #007acc;
              "
            >
              <div
                style="
                  width: 20px;
                  height: 20px;
                  border: 2px solid #007acc;
                  border-top: 2px solid transparent;
                  border-radius: 50%;
                  animation: spin 1s linear infinite;
                "
              ></div>
              <span>Loading...</span>
            </div>
          </div>

          <div class="phase error-phase" data-phase="error" id="error">
            <div
              style="
                display: flex;
                align-items: center;
                gap: 10px;
                color: #dc3545;
              "
            >
              <div style="width: 20px; height: 20px; color: #dc3545">⚠️</div>
              <p>
                An error occurred

                <br />
                <br />
                Please try again later.
              </p>
            </div>
          </div>
        </div>
      </details>
    </div>

    <!-- Zone de transition -->
    <div class="transition-zone">
      <h4>Zone de transition:</h4>
      <div class="transition-viewport">
        <div class="ui_transition">
          <div class="active_group">
            <div class="target_slot"></div>
            <div class="outgoing_slot"></div>
          </div>

          <div class="previous_group">
            <div class="previous_target_slot"></div>
            <div class="previous_outgoing_slot"></div>
          </div>
        </div>
      </div>
      <!-- Contrôles -->
      <div class="controls-container">
        <!-- Première partie : Durée et Alignement -->
        <div class="settings-controls">
          <label class="duration-control">
            <span>Durée:</span>
            <input
              type="range"
              id="duration-slider"
              min="500"
              max="5000"
              step="100"
              value="3000"
            />
            <span id="duration-value">3000ms</span>
          </label>

          <div class="alignment-controls">
            <label class="align-control">
              <span>X:</span>
              <select id="align-x-select">
                <option value="start">start</option>
                <option value="center">center</option>
                <option value="end">end</option>
              </select>
            </label>

            <label class="align-control">
              <span>Y:</span>
              <select id="align-y-select">
                <option value="start">start</option>
                <option value="center">center</option>
                <option value="end">end</option>
              </select>
            </label>
          </div>

          <div class="initial-content-controls">
            <label class="align-control">
              <input type="checkbox" id="initial-content-checkbox" checked />
              <span>Démarrer avec contenu initial</span>
            </label>
          </div>
        </div>

        <!-- Seconde partie : Actions -->
        <div class="action-controls">
          <button id="empty-button">Vider la zone</button>
          <button id="reset-button">Reset (état initial)</button>
        </div>
      </div>
    </div>

    <div class="debug-info" id="debug">
      <div><strong>Debug Info:</strong></div>
      <div id="container-size">Container: 200px × 100px</div>
      <div id="content-size">Content naturel: -</div>
      <div id="scale-info">Scale: 1</div>
      <div id="state-info">État: A</div>
    </div>

    <script type="module">
      import { createUITransitionController } from "./poc_ui_transition.js";

      // Configuration localStorage
      const STORAGE_KEY = "smoothResizeTransition";

      // Load preferences from localStorage
      function loadPreferences() {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (saved) {
            const prefs = JSON.parse(saved);
            return {
              duration: prefs.duration || 3000,
              alignX: prefs.alignX || "center",
              alignY: prefs.alignY || "center",
              hasInitialContent:
                prefs.hasInitialContent !== undefined
                  ? prefs.hasInitialContent
                  : true,
            };
          }
        } catch (e) {
          console.warn("Erreur lors du chargement des préférences:", e);
        }
        return {
          duration: 3000,
          alignX: "center",
          alignY: "center",
          hasInitialContent: true,
        };
      }

      // Save preferences to localStorage
      function savePreferences(prefs) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(prefs));
          console.log("Préférences sauvegardées:", prefs);
        } catch (e) {
          console.warn("Erreur lors de la sauvegarde des préférences:", e);
        }
      }

      // Demo state and UI management
      let currentState = "empty";
      const savedPrefs = loadPreferences();

      // Initialize UITransition
      const uiTransition = createUITransitionController(
        document.querySelector(".ui_transition"),
        {
          duration: savedPrefs.duration,
          alignX: savedPrefs.alignX,
          alignY: savedPrefs.alignY,
          onStateChange: updateUIState,
        },
      );

      // Debug info elements
      const debug = {
        containerSize: document.getElementById("container-size"),
        contentSize: document.getElementById("content-size"),
        scaleInfo: document.getElementById("scale-info"),
        stateInfo: document.getElementById("state-info"),
      };

      // Update UI state during transitions
      function updateUIState({ isTransitioning }) {
        // Only disable UI elements outside the transition zone
        const rectangles = document.querySelectorAll(
          ".content-items .rectangle, .phase-items .phase",
        );
        const controls = document.querySelector(".controls-container");
        const emptyButton = document.getElementById("empty-button");
        const resetButton = document.getElementById("reset-button");

        if (isTransitioning) {
          rectangles.forEach((rect) => {
            rect.classList.add("disabled");
            rect.style.pointerEvents = "none";
          });

          if (controls) {
            controls.classList.add("controls-disabled");
          }

          if (emptyButton) {
            emptyButton.disabled = true;
            emptyButton.textContent = "Transition en cours...";
          }

          if (resetButton) {
            resetButton.disabled = true;
            resetButton.textContent = "Transition en cours...";
          }

          debug.scaleInfo.textContent =
            "⚠️ Transition en cours - Interface désactivée";
        } else {
          rectangles.forEach((rect) => {
            rect.classList.remove("disabled");
            rect.style.pointerEvents = "auto";
          });

          if (controls) {
            controls.classList.remove("controls-disabled");
          }

          if (emptyButton) {
            emptyButton.disabled = false;
            emptyButton.textContent = "Vider la zone";
          }

          if (resetButton) {
            resetButton.disabled = false;
            resetButton.textContent = "Reset (état initial)";
          }

          debug.scaleInfo.textContent = `Clone utilisé: ${isTransitioning ? "Oui" : "Non"}`;
        }
      }

      // Update debug info
      function updateDebugInfo() {
        const container = document.querySelector(".ui_transition");
        const containerRect = container.getBoundingClientRect();
        const currentContent = container.querySelector(".target_slot");
        const contentRect = currentContent.getBoundingClientRect();

        debug.containerSize.textContent = `Container: ${containerRect.width.toFixed(0)}px × ${containerRect.height.toFixed(0)}px`;
        debug.contentSize.textContent = `Content: ${contentRect.width.toFixed(0)}px × ${contentRect.height.toFixed(0)}px`;
        debug.stateInfo.textContent = `État: ${currentState.toUpperCase()}`;
      }

      // Setup unified click handlers for both content and phases
      function setupClickHandlers() {
        document.addEventListener("click", (e) => {
          const rectangle = e.target.closest(".rectangle");
          const phase = e.target.closest(".phase");

          if (rectangle) {
            const state = rectangle.dataset.state;
            if (state && state !== currentState) {
              uiTransition.transitionTo(rectangle.cloneNode(true));
              currentState = state;
            }
          } else if (phase) {
            const phaseType = phase.dataset.phase;
            if (phaseType) {
              // Use transitionTo with isContentPhase option
              uiTransition.transitionTo(phase.cloneNode(true), {
                isContentPhase: true,
              });
              currentState = `phase-${phaseType}`;
            }
          }
        });
      }

      // Apply alignment - single place for all alignment logic
      function applyAlignment(alignX, alignY) {
        // Update UI transition component
        uiTransition.setAlignment(alignX, alignY);

        const viewport = document.querySelector(".transition-viewport");
        viewport.style.alignItems = alignY;
        viewport.style.justifyContent = alignX;

        // Update form controls to reflect current state
        const alignXSelect = document.getElementById("align-x-select");
        const alignYSelect = document.getElementById("align-y-select");

        if (alignXSelect) alignXSelect.value = alignX;
        if (alignYSelect) alignYSelect.value = alignY;

        // Save preferences
        const currentPrefs = loadPreferences();
        const updatedPrefs = { ...currentPrefs, alignX, alignY };
        savePreferences(updatedPrefs);

        console.log(`Alignment applied: X=${alignX}, Y=${alignY}`);
      }

      // Setup controls
      function setupControls() {
        // Empty button - transitions to completely empty
        const emptyButton = document.getElementById("empty-button");
        if (emptyButton) {
          emptyButton.addEventListener("click", () => {
            console.log("Transitioning to empty state");
            uiTransition.transitionTo(null);
            currentState = "empty";
          });
        }

        // Reset button - returns to initial state with placeholder content
        const resetButton = document.getElementById("reset-button");
        if (resetButton) {
          resetButton.addEventListener("click", () => {
            const prefs = loadPreferences();

            if (prefs.hasInitialContent) {
              const emptyElement = document.createElement("div");
              emptyElement.className = "content state-empty";
              emptyElement.innerHTML =
                "<p>Cliquez sur un rectangle ci-dessus pour voir la transition se lancer</p>";

              console.log("Resetting to initial state with content");
              uiTransition.resetContent(emptyElement);
              currentState = "initial";
            } else {
              console.log("Resetting to empty state");
              uiTransition.transitionTo(null);
              currentState = "empty";
            }
          });
        }

        // Duration control
        const durationSlider = document.getElementById("duration-slider");
        const durationValue = document.getElementById("duration-value");

        if (durationSlider && durationValue) {
          durationSlider.value = savedPrefs.duration;
          durationValue.textContent = `${savedPrefs.duration}ms`;

          durationSlider.addEventListener("input", (e) => {
            const duration = parseInt(e.target.value);
            durationValue.textContent = `${duration}ms`;
            uiTransition.setDuration(duration);

            const prefs = { ...loadPreferences(), duration };
            savePreferences(prefs);
          });
        }

        // Alignment controls
        const alignXSelect = document.getElementById("align-x-select");
        const alignYSelect = document.getElementById("align-y-select");

        if (alignXSelect) {
          alignXSelect.value = savedPrefs.alignX;
          alignXSelect.addEventListener("change", (e) => {
            const currentY = alignYSelect
              ? alignYSelect.value
              : savedPrefs.alignY;
            applyAlignment(e.target.value, currentY);
          });
        }

        if (alignYSelect) {
          alignYSelect.value = savedPrefs.alignY;
          alignYSelect.addEventListener("change", (e) => {
            const currentX = alignXSelect
              ? alignXSelect.value
              : savedPrefs.alignX;
            applyAlignment(currentX, e.target.value);
          });
        }

        // Initial content checkbox
        const initialContentCheckbox = document.getElementById(
          "initial-content-checkbox",
        );
        if (initialContentCheckbox) {
          initialContentCheckbox.checked = savedPrefs.hasInitialContent;

          // Update reset button text based on checkbox state
          const updateResetButtonText = () => {
            const resetButton = document.getElementById("reset-button");
            if (resetButton) {
              resetButton.textContent = initialContentCheckbox.checked
                ? "Reset (état initial avec hint)"
                : "Reset (état vide)";
            }
          };

          // Initial text update
          updateResetButtonText();

          initialContentCheckbox.addEventListener("change", (e) => {
            const prefs = {
              ...loadPreferences(),
              hasInitialContent: e.target.checked,
            };
            savePreferences(prefs);

            // Update reset button text
            updateResetButtonText();

            if (e.target.checked) {
              // Add initial content if not already present
              if (currentState === "empty") {
                const emptyElement = document.createElement("div");
                emptyElement.className = "content state-empty";
                emptyElement.innerHTML =
                  "<p>Cliquez sur un rectangle ci-dessus pour voir la transition</p>";
                uiTransition.transitionTo(emptyElement);
                currentState = "initial";
              }
            } else if (currentState === "initial") {
              // Remove content if it's the initial content
              uiTransition.transitionTo(null);
              currentState = "empty";
            }
          });
        }
      }

      // Initialization
      function init() {
        setupClickHandlers();
        setupControls();

        // Apply initial alignment
        applyAlignment(savedPrefs.alignX, savedPrefs.alignY);

        // Apply initial content preference
        if (savedPrefs.hasInitialContent) {
          // Add initial content if preference is enabled
          const emptyElement = document.createElement("div");
          emptyElement.className = "content state-empty";
          emptyElement.innerHTML =
            "<p>Cliquez sur un rectangle ci-dessus pour voir la transition</p>";
          uiTransition.transitionTo(emptyElement);
          currentState = "initial";
        } else {
          currentState = "empty";
        }

        updateDebugInfo();

        // Continuous debug info updates
        setInterval(updateDebugInfo, 200);

        console.log(
          "Interface initialisée - cliquez sur les rectangles pour transitionner",
        );
      }

      // Start when DOM is ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    </script>
  </body>
</html>
