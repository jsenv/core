<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route inspector</title>
    
  </head>
  <body>
    <div id="app"></div>

    <style>.progress-container {
  background-color: #1976d233;
  border-radius: 4px;
  width: 100%;
  height: 100%;
  margin: 20px 0;
  position: relative;
  overflow: hidden;
}

.progress-indeterminate .progress-bar-long, .progress-indeterminate .progress-bar-short {
  background-color: #1976d2;
  border-radius: 4px;
  height: 100%;
  animation-duration: 2.2s;
  animation-iteration-count: infinite;
  position: absolute;
  top: 0;
}

.progress-indeterminate .progress-bar-long {
  width: 75%;
  animation-name: indeterminate-ltr;
}

.progress-indeterminate .progress-bar-short {
  width: 20%;
  animation-name: indeterminate-short-ltr;
}

@keyframes indeterminate-ltr {
  0% {
    left: -90%;
    right: 100%;
  }

  60% {
    left: -90%;
    right: 100%;
  }

  100% {
    left: 100%;
    right: -35%;
  }
}

@keyframes indeterminate-short-ltr {
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
}

.route-list {
  margin-top: 20px;
}

.route-item {
  align-items: center;
  margin-bottom: 8px;
  display: flex;
}

.route-method {
  min-width: 60px;
  font-weight: bold;
}

.route-resource {
  margin-left: 8px;
}
</style>
    <script type="module">
      // https://preactjs.com/guide/v10/no-build-workflows/
      import { render } from "https://esm.sh/preact@10.23.1";
      import { html } from "https://esm.sh/htm@3.1.1/preact?external=preact";
      import { signal } from "https://esm.sh/@preact/signals@1.3.0?external=preact";

      const routesLoadingSignal = signal(false);
      const routeLoadingError = signal(null);
      const routesSignal = signal([]);

      const loadRoutes = async () => {
        // routesLoadingSignal.value = true;
        // try {
        //   const response = await fetch(window.location.href, {
        //     headers: {
        //       accept: "application/json",
        //     },
        //   });
        //   const routes = await response.json();
        //   routesLoadingSignal.value = false;
        //   routesSignal.value = routes;
        // } catch (e) {
        //   routesLoadingSignal.value = false;
        //   routeLoadingError.value = e;
        //   throw e;
        // }
      };
      loadRoutes();

      const ProgressBar = ({ width = "100%", height = 6, loading }) => {
        if (!loading) {
          return null;
        }
        return html`
          <div
            class="progress-bar"
            style=${{
              width: typeof Number(width) === "number" ? `${width}px` : width,
              height:
                typeof Number(height) === "number" ? `${height}px` : height,
            }}
          >
            <div class="progress-container progress-indeterminate">
              <div class="progress-bar-long"></div>
              <div class="progress-bar-short"></div>
            </div>
          </div>
        `;
      };

      const App = () => {
        const routes = routesSignal.value;
        const loading = routesLoadingSignal.value;

        return html`
          <h1>Route inspector</h1>
          ${loading ? html`<p>Loading...</p>` : null}
          <${ProgressBar} width="150" loading=${loading} />
          <${RouteList} routes=${routes} />
        `;
      };
      const RouteList = ({ routes }) => {
        return html`<div>
          ${routes.map((route) => html`<${Route} ...${route} />`)}
        </div>`;
      };
      const Route = ({ method, resource }) => {
        return html`<div style="display: flex">
          <span>${method}</span>
          <p>${resource}</p>
        </div>`;
      };

      render(html`<${App} />`, document.getElementById("app"));
    </script>
    <script>
      const css = /* css */ `
      dialog {
        opacity: 0;
        transition: all 0.3s allow-discrete;
      }
      dialog::backdrop {
         background-image: linear-gradient(
          45deg,
          magenta,
          rebeccapurple,
          dodgerblue,
          green
        );
        opacity: 0;
        transition: all 0.3s allow-discrete;
      }
      dialog:open {
        opacity: 1;
      }
      dialog:open::backdrop {
        opacity: 0.75;
      }`;
      
      const html = /* html */ `<style>
          ${css}
      </style>
      <dialog>
          <p>Connection with server is lost</p>
          <button autofocus name="reconnect">Retry</button>
      </dialog>`;
      
      class JsenvAutoreloadOnServerRestart extends HTMLElement {
        constructor({ url } = {}) {
          super();
          const root = this.attachShadow({ mode: "open" });
          root.innerHTML = html;
      
          const dialog = root.querySelector("dialog");
          const reconnectButton = dialog.querySelector('button[name="reconnect"]');
      
          (async () => {
            const connect = () => {
              const websocket = new WebSocket(url, ["jsenv_server"]);
              const connectedPromise = new Promise((resolve) => {
                websocket.onerror = () => {
                  resolve(null);
                };
                websocket.onopen = () => {
                  resolve(websocket);
                };
              });
              return connectedPromise;
            };
      
            const initialWebSocket = await connect();
            initialWebSocket.onclose = async () => {
              console.info("connection to server lost, trying to reconnect");
              const retry = async () => {
                let attemptCount = 0;
                const tryToReconnect = async () => {
                  const newWebsocket = await connect();
                  if (newWebsocket) {
                    dialog.close();
                    console.info("reconnected to server, reloading the page...");
                    window.location.reload(true);
                    return;
                  }
                  attemptCount++;
                  if (attemptCount === 5) {
                    dialog.showModal();
                    reconnectButton.onclick = async () => {
                      reconnectButton.disabled = true;
                      const previousContext = reconnectButton.textContent;
                      reconnectButton.textContent = "Retrying...";
                      await retry();
                      reconnectButton.textContent = previousContext;
                      reconnectButton.disabled = false;
                    };
                    return;
                  }
                  await new Promise((resolve) => setTimeout(resolve, 200));
                  await tryToReconnect();
                };
                await tryToReconnect();
              };
              retry();
            };
          })();
        }
      }
      if (!customElements.get("jsenv-autoreload-on-server-restart")) {
        customElements.define(
          "jsenv-autoreload-on-server-restart",
          JsenvAutoreloadOnServerRestart,
        );
      }
      
      const jsenvAutoreloadOnServerRestartElement =
        new JsenvAutoreloadOnServerRestart({
          url: (() => {
            const websocketScheme =
              self.location.protocol === "https:" ? "wss" : "ws";
            const websocketUrl = `${websocketScheme}://${self.location.host}${self.location.pathname}${self.location.search}`;
            return websocketUrl;
          })(),
        });
      
      document.currentScript.parentNode.replaceChild(
        jsenvAutoreloadOnServerRestartElement,
        document.currentScript,
      );
    </script>
  </body>
</html>