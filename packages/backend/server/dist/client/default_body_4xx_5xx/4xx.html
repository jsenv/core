<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${status} ${statusText}</title>
    <style>body {
  color: #333;
  background-color: #f8f9fa;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  margin: 0;
  font-family: Arial, sans-serif;
  display: flex;
}

.error_container {
  text-align: center;
  background: #fff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 4px 6px #0000001a;
}

.error_status {
  color: #dc3545;
  margin: 0;
  font-size: 5rem;
}

.error_status_text {
  text-align: left;
  word-break: break-word;
  margin: 10px 0;
  font-size: 1.5rem;
}

.error_message {
  color: #555;
  text-align: left;
  word-break: break-word;
  font-size: 1rem;
}

.home_link {
  color: #fff;
  background-color: #007bff;
  border-radius: 5px;
  margin-top: 15px;
  padding: 10px 15px;
  text-decoration: none;
  display: inline-block;
}

.home_link:hover {
  background-color: #0056b3;
}
</style>
  </head>
  <body>
    <div class="error_container">
      <p class="error_status">${status}</p>
      <p class="error_status_text">${statusText}</p>
      <p class="error_message">${statusMessage}</p>
      <a href="/" jsenv-ignore="" class="home_link">Return to Home</a>
    </div>
    <script>
      const css = /* css */ `
        dialog {
          opacity: 0;
          transition: all 0.3s allow-discrete;
        }
        dialog::backdrop {
          background-image: linear-gradient(
            45deg,
            magenta,
            rebeccapurple,
            dodgerblue,
            green
          );
          opacity: 0;
          transition: all 0.3s allow-discrete;
        }
        dialog:open {
          opacity: 1;
        }
        dialog:open::backdrop {
          opacity: 0.75;
        }
      `;
      
      const html = /* html */ `<style>
          ${css}
        </style>
        <dialog>
          <p>Connection with server is lost</p>
          <button autofocus name="reconnect">Retry</button>
        </dialog>`;
      
      class JsenvAutoreloadOnServerRestart extends HTMLElement {
        constructor({ url } = {}) {
          super();
          const root = this.attachShadow({ mode: "open" });
          root.innerHTML = html;
      
          const dialog = root.querySelector("dialog");
          const reconnectButton = dialog.querySelector('button[name="reconnect"]');
      
          (async () => {
            const connect = () => {
              const websocket = new WebSocket(url);
              const connectedPromise = new Promise((resolve) => {
                websocket.onerror = () => {
                  resolve(null);
                };
                websocket.onopen = () => {
                  resolve(websocket);
                };
              });
              return connectedPromise;
            };
      
            const initialWebSocket = await connect();
            if (!initialWebSocket) {
              return;
            }
            initialWebSocket.onclose = async () => {
              console.info("connection to server lost, trying to reconnect");
              const retry = async () => {
                let attemptCount = 0;
                let timeToWait = 100;
                const tryToReconnect = async () => {
                  const newWebsocket = await connect();
                  if (newWebsocket) {
                    dialog.close();
                    console.info("reconnected to server, reloading the page...");
                    window.location.reload(true);
                    return;
                  }
                  attemptCount++;
                  if (attemptCount === 10) {
                    dialog.showModal();
                    reconnectButton.onclick = async () => {
                      reconnectButton.disabled = true;
                      const previousContext = reconnectButton.textContent;
                      reconnectButton.textContent = "Retrying...";
                      await retry();
                      reconnectButton.textContent = previousContext;
                      reconnectButton.disabled = false;
                    };
                    return;
                  }
                  timeToWait += 100;
                  await new Promise((resolve) => setTimeout(resolve, timeToWait));
                  await tryToReconnect();
                };
                await tryToReconnect();
              };
              retry();
            };
          })();
        }
      }
      if (!customElements.get("jsenv-autoreload-on-server-restart")) {
        customElements.define(
          "jsenv-autoreload-on-server-restart",
          JsenvAutoreloadOnServerRestart,
        );
      }
      
      const websocketEndpoint =
        document.currentScript.getAttribute("data-ws-endpoint") ||
        "/.internal/alive.websocket";
      
      const jsenvAutoreloadOnServerRestartElement =
        new JsenvAutoreloadOnServerRestart({
          url: (() => {
            const websocketScheme =
              self.location.protocol === "https:" ? "wss" : "ws";
            const websocketUrl = `${websocketScheme}://${self.location.host}${websocketEndpoint}`;
            return websocketUrl;
          })(),
        });
      
      // script is injected into document.body
      if (document.body) {
        document.currentScript.parentNode.replaceChild(
          jsenvAutoreloadOnServerRestartElement,
          document.currentScript,
        );
      }
      // script injected outisde document.body (likely in head)
      else {
        document.currentScript.parentNode.removeChild(document.currentScript);
        document.onreadystatechange = () => {
          if (document.readyState === "interactive") {
            document.body.appendChild(jsenvAutoreloadOnServerRestartElement);
          }
        };
      }
    </script>
  </body>
</html>