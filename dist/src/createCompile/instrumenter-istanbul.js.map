{"version":3,"sources":["../../../src/createCompile/instrumenter-istanbul.js"],"names":["instrumenter","inputRelativeLocation","inputSource","inputSourceMap","inputAst","coverageGlobalVariabeName","istanbulInstrumenter","Instrumenter","coverageVariable","esModules","embedSource","includes","codeGenerationOptions","sourceMap","sourceContent","sourceMapWithCode","file","outputSource","instrumentASTSync","instrumentSync","outputSourceMap","lastSourceMap","inputCodeSourceMapConsumer","intrumentedCodeSourceMapConsumer","generator","fromSourceMap","applySourceMap","JSON","parse","toString"],"mappings":";;;;;;;AAEA;;;;AAEA;;;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvBA;AACA;AAwBO,IAAMA,sCAAe,SAAfA,YAAe,OAMtB;AAAA,MALJC,qBAKI,QALJA,qBAKI;AAAA,MAJJC,WAII,QAJJA,WAII;AAAA,MAHJC,cAGI,QAHJA,cAGI;AAAA,MAFJC,QAEI,QAFJA,QAEI;AAAA,mCADJC,yBACI;AAAA,MADJA,yBACI,yCADwB,cACxB;;AACJ;AACA,MAAMC,uBAAuB,IAAI,sBAASC,YAAb,CAA0B;AACrDC,sBAAkBH,yBADmC;AAErDI,eAAW,IAF0C;AAGrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,iBAAaT,sBAAsBU,QAAtB,CAA+B,WAA/B,CAXwC;AAYrDC,2BAAuB;AACrB;AACA;AACAC,iBAAWZ,qBAHU;AAIrBa,qBAAeZ,WAJM;AAKrBa,yBAAmB,IALE;AAMrBC,YAAMf;AANe;AAZ8B,GAA1B,CAA7B;;AAsBA,MAAMgB,eAAeb,WACjBE,qBAAqBY,iBAArB,CAAuCd,QAAvC,EAAiDH,qBAAjD,EAAwEC,WAAxE,CADiB,GAEjBI,qBAAqBa,cAArB,CAAoCjB,WAApC,EAAiDD,qBAAjD,CAFJ;AAGA,MAAMmB,kBAAkBd,qBAAqBe,aAArB,EAAxB;;AAEA,MAAIlB,cAAJ,EAAoB;AAClB;AACA,QAAMmB,6BAA6B,iCAAsBnB,cAAtB,CAAnC;AACA,QAAMoB,mCAAmC,iCAAsBH,eAAtB,CAAzC;AACA,QAAMI,YAAY,8BAAmBC,aAAnB,CAAiCF,gCAAjC,CAAlB;AACAC,cAAUE,cAAV,CAAyBJ,0BAAzB;;AAEA,WAAO;AACLjB,0DADK;AAELY,gCAFK;AAGLG,uBAAiBO,KAAKC,KAAL,CAAWJ,UAAUK,QAAV,EAAX;AAHZ,KAAP;AAKD;;AAED,SAAO;AACLxB,wDADK;AAELY,8BAFK;AAGLG;AAHK,GAAP;AAKD,CAtDM;AAtBP","file":"instrumenter-istanbul.js","sourcesContent":["// why not https://github.com/istanbuljs/babel-plugin-istanbul ?\n// https://github.com/guybedford/systemjs-istanbul/blob/master/index.js\nimport istanbul from \"istanbul\"\n// import remapIstanbul from \"remap-istanbul/lib/remap\" // \"remap-istanbul\": \"0.8.4\",\nimport { SourceMapConsumer, SourceMapGenerator } from \"source-map\"\n\n// const getCoverage = ({ globalName }) => {\n//   return global[globalName]\n// }\n\n// // remap coverage will be needed later so that our coverage object\n// // is remapped using sourcemaps\n// const remapCoverage = (coverage) => {\n//   return remapIstanbul(coverage)\n// }\n\n// const getCoverageGlobalVariableName = () => {\n//   for (const key in global) {\n//     if (key.match(/\\$\\$cov_\\d+\\$\\$/)) {\n//       return key\n//     }\n//   }\n//   return null\n// }\n\nexport const instrumenter = ({\n  inputRelativeLocation,\n  inputSource,\n  inputSourceMap,\n  inputAst,\n  coverageGlobalVariabeName = \"__coverage__\",\n}) => {\n  // http://gotwarlost.github.io/istanbul/public/apidocs/classes/Instrumenter.html\n  const istanbulInstrumenter = new istanbul.Instrumenter({\n    coverageVariable: coverageGlobalVariabeName,\n    esModules: true,\n    // tod: put this to true if the instrumented module is anonymous\n    // a way to know if the module is register anonymously doing System.module is to check if it's adress looks like\n    // '<Anonymous Module ' + ++anonCnt + '>';\n    // https://github.com/ModuleLoader/es6-module-loader/issues/489\n    // but if the anonymous module provide an adress you're fucked\n    // also when a normal module use <Anonymous Module 1> name\n    // in both cases we would consider it as anonymous by mistake\n    // for now we will enable embedSource if the load.address includes anonymous somewhere\n    embedSource: inputRelativeLocation.includes(\"anonymous\"),\n    codeGenerationOptions: {\n      // il faut passer le fichier d'origine, sauf que ce fichier n'est pas dispo sur le fs puisque transpiled\n      // il le sera ptet par la suite\n      sourceMap: inputRelativeLocation,\n      sourceContent: inputSource,\n      sourceMapWithCode: true,\n      file: inputRelativeLocation,\n    },\n  })\n\n  const outputSource = inputAst\n    ? istanbulInstrumenter.instrumentASTSync(inputAst, inputRelativeLocation, inputSource)\n    : istanbulInstrumenter.instrumentSync(inputSource, inputRelativeLocation)\n  const outputSourceMap = istanbulInstrumenter.lastSourceMap()\n\n  if (inputSourceMap) {\n    // https://github.com/karma-runner/karma-coverage/pull/146/files\n    const inputCodeSourceMapConsumer = new SourceMapConsumer(inputSourceMap)\n    const intrumentedCodeSourceMapConsumer = new SourceMapConsumer(outputSourceMap)\n    const generator = SourceMapGenerator.fromSourceMap(intrumentedCodeSourceMapConsumer)\n    generator.applySourceMap(inputCodeSourceMapConsumer)\n\n    return {\n      coverageGlobalVariabeName,\n      outputSource,\n      outputSourceMap: JSON.parse(generator.toString()),\n    }\n  }\n\n  return {\n    coverageGlobalVariabeName,\n    outputSource,\n    outputSourceMap,\n  }\n}\n"]}