{
  "version": 3,
  "sources": [
    "../../../src/createCompileService/createCompileService.js"
  ],
  "names": [
    "compareBranch",
    "branchA",
    "branchB",
    "lastMatchDiff",
    "lastMatchMs",
    "matchCount",
    "getInputRelativeLocation",
    "abstractFolderRelativeLocation",
    "filename",
    "slice",
    "length",
    "getCacheFolderLocation",
    "rootLocation",
    "cacheFolderRelativeLocation",
    "rest",
    "getCacheDataLocation",
    "param",
    "JSON_FILE",
    "getBranchRelativeLocation",
    "branch",
    "name",
    "getOutputRelativeLocation",
    "path",
    "basename",
    "getBranchLocation",
    "getOutputLocation",
    "getOutputAssetLocation",
    "asset",
    "readBranchMain",
    "inputLocation",
    "inputETagClient",
    "cache",
    "location",
    "then",
    "content",
    "inputETag",
    "Promise",
    "resolve",
    "status",
    "inputETagCached",
    "outputLocation",
    "errorHandler",
    "isFileNotFoundError",
    "error",
    "output",
    "moreData",
    "input",
    "readBranchAsset",
    "outputAssetLocation",
    "actual",
    "expected",
    "eTag",
    "inputRelativeLocation",
    "readBranch",
    "all",
    "outputAssets",
    "map",
    "outputAsset",
    "mainData",
    "assetsData",
    "computedStatus",
    "invalidAsset",
    "find",
    "assetData",
    "getSourceAbstractLocation",
    "getSourceMapLocation",
    "outputRelativeLocation",
    "outputSourceMapName",
    "dirname",
    "sourceMapKnowsExactLocation",
    "getSourceMapAbstractpLocation",
    "getFileBranch",
    "compile",
    "cacheDataLocation",
    "branches",
    "JSON",
    "parse",
    "Error",
    "inputSource",
    "getSourceNameForSourceMap",
    "getSourceLocationForSourceMap",
    "context",
    "sourceMapUseAbsoluteLocation",
    "sourceLocation",
    "sourceMapLocation",
    "sourceLocationRelativeToSourceMapLocation",
    "relative",
    "options",
    "generate",
    "branchIsValid",
    "stringify",
    "outputMeta",
    "cachedBranch",
    "getFileReport",
    "updateBranch",
    "cacheAutoClean",
    "cacheTrackHit",
    "isCached",
    "isNew",
    "isUpdated",
    "promises",
    "mainLocation",
    "push",
    "assetLocation",
    "branchesToRemove",
    "index",
    "indexOf",
    "splice",
    "forEach",
    "branchLocation",
    "console",
    "log",
    "updatedBranches",
    "branchToUpdate",
    "Number",
    "Date",
    "now",
    "lastModifiedMs",
    "createdMs",
    "sort",
    "updatedCache",
    "undefined",
    "getFileCompiled",
    "cacheEnabled",
    "fileLock",
    "chain",
    "createCompileService",
    "fileService",
    "service",
    "method",
    "url",
    "headers",
    "pathname",
    "endsWith",
    "script",
    "scriptCompiledFolder",
    "URL",
    "search",
    "reason",
    "reject",
    "has",
    "get",
    "Etag",
    "Buffer",
    "byteLength",
    "body",
    "compileFile",
    "relativeLocation"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* eslint-disable import/max-dependencies */\nimport cuid from \"cuid\"\nimport path from \"path\"\nimport { URL } from \"url\"\nimport { createCompile } from \"../createCompile/createCompile.js\"\nimport { JSON_FILE } from \"./cache.js\"\nimport {\n  createETag,\n  isFileNotFoundError,\n  resolvePath,\n  removeFolderDeep,\n  normalizeSeparation,\n} from \"./helpers.js\"\nimport { locateFile } from \"./locateFile.js\"\nimport { readFile } from \"./readFile.js\"\nimport { lockForRessource } from \"./ressourceRegistry.js\"\nimport { writeFileFromString } from \"@dmail/project-structure-compile-babel\"\nimport { createFileService } from \"../createFileService/createFileService.js\"\n\nconst compareBranch = (branchA, branchB) => {\n  const lastMatchDiff = branchA.lastMatchMs - branchB.lastMatchMs\n\n  if (lastMatchDiff === 0) {\n    return branchA.matchCount - branchB.matchCount\n  }\n  return lastMatchDiff\n}\n\nconst getInputRelativeLocation = ({ abstractFolderRelativeLocation, filename }) => {\n  // 'compiled/folder/file.js' -> 'folder/file.js'\n  return filename.slice(abstractFolderRelativeLocation.length + 1)\n}\n\nconst getCacheFolderLocation = ({ rootLocation, cacheFolderRelativeLocation, ...rest }) => {\n  return resolvePath(rootLocation, cacheFolderRelativeLocation, getInputRelativeLocation(rest))\n}\n\nconst getCacheDataLocation = (param) => {\n  return resolvePath(getCacheFolderLocation(param), JSON_FILE)\n}\n\nconst getBranchRelativeLocation = ({ cacheFolderRelativeLocation, branch, ...rest }) => {\n  return resolvePath(cacheFolderRelativeLocation, getInputRelativeLocation(rest), branch.name)\n}\n\nconst getOutputRelativeLocation = ({ filename, ...rest }) => {\n  return resolvePath(getBranchRelativeLocation({ filename, ...rest }), path.basename(filename))\n}\n\nconst getBranchLocation = ({ rootLocation, ...rest }) => {\n  return resolvePath(rootLocation, getBranchRelativeLocation(rest))\n}\n\nconst getOutputLocation = ({ rootLocation, ...rest }) => {\n  return resolvePath(rootLocation, getOutputRelativeLocation(rest))\n}\n\nconst getOutputAssetLocation = ({ asset, ...rest }) => {\n  return resolvePath(getBranchLocation(rest), asset.name)\n}\n\nconst readBranchMain = ({\n  rootLocation,\n  cacheFolderRelativeLocation,\n  abstractFolderRelativeLocation,\n  filename,\n  inputLocation,\n  inputETagClient,\n  cache,\n  branch,\n}) => {\n  return readFile({ location: inputLocation }).then(({ content }) => {\n    const inputETag = createETag(content)\n\n    return Promise.resolve()\n      .then(() => {\n        // faudra pouvoir désactiver ce check lorsqu'on veut juste connaitre l'état du cache\n        if (inputETagClient) {\n          if (inputETag !== inputETagClient) {\n            return {\n              status: `eTag modified on ${inputLocation} since it was cached by client`,\n              inputETagClient,\n            }\n          }\n          return { status: \"valid\" }\n        }\n\n        const inputETagCached = cache.inputETag\n        if (inputETag !== inputETagCached) {\n          return {\n            status: `eTag modified on ${inputLocation} since it was cached on filesystem`,\n            inputETagCached,\n          }\n        }\n\n        const outputLocation = getOutputLocation({\n          rootLocation,\n          cacheFolderRelativeLocation,\n          abstractFolderRelativeLocation,\n          filename,\n          branch,\n        })\n        return readFile({\n          location: outputLocation,\n          errorHandler: isFileNotFoundError,\n        }).then(({ content, error }) => {\n          if (error) {\n            return {\n              status: `cache not found at ${outputLocation}`,\n            }\n          }\n          return { status: \"valid\", output: content }\n        })\n      })\n      .then((moreData) => {\n        return {\n          input: content,\n          inputETag,\n          ...moreData,\n        }\n      })\n  })\n}\n\nconst readBranchAsset = ({\n  rootLocation,\n  cacheFolderRelativeLocation,\n  abstractFolderRelativeLocation,\n  filename,\n  cache,\n  branch,\n  asset,\n}) => {\n  const outputAssetLocation = getOutputAssetLocation({\n    rootLocation,\n    cacheFolderRelativeLocation,\n    abstractFolderRelativeLocation,\n    filename,\n    branch,\n    asset,\n  })\n  const name = asset.name\n\n  return readFile({\n    location: outputAssetLocation,\n    errorHandler: isFileNotFoundError,\n  }).then(({ content, error }) => {\n    if (error) {\n      return {\n        status: `asset file not found ${outputAssetLocation}`,\n        name,\n      }\n    }\n\n    const actual = createETag(content)\n    const expected = asset.eTag\n    if (actual !== expected) {\n      return {\n        status: `unexpected ${asset.name} asset for ${\n          cache.inputRelativeLocation\n        }: unexpected eTag`,\n        name,\n        content,\n      }\n    }\n    return {\n      status: \"valid\",\n      name,\n      content,\n    }\n  })\n}\n\nconst readBranch = ({\n  rootLocation,\n  cacheFolderRelativeLocation,\n  abstractFolderRelativeLocation,\n  filename,\n  inputLocation,\n  inputETagClient,\n  cache,\n  branch,\n}) => {\n  return Promise.all([\n    readBranchMain({\n      rootLocation,\n      cacheFolderRelativeLocation,\n      abstractFolderRelativeLocation,\n      filename,\n      inputLocation,\n      inputETagClient,\n      cache,\n      branch,\n    }),\n    ...branch.outputAssets.map((outputAsset) => {\n      return readBranchAsset({\n        rootLocation,\n        cacheFolderRelativeLocation,\n        abstractFolderRelativeLocation,\n        filename,\n        cache,\n        branch,\n        asset: outputAsset,\n      })\n    }),\n  ]).then(([mainData, ...assetsData]) => {\n    const { status, input, inputETag, output } = mainData\n\n    let computedStatus\n    if (status === \"valid\") {\n      const invalidAsset = assetsData.find((assetData) => assetData.status !== \"valid\")\n      computedStatus = invalidAsset ? invalidAsset.status : \"valid\"\n    } else {\n      computedStatus = status\n    }\n\n    return {\n      status: computedStatus,\n      input,\n      inputETag,\n      output,\n      outputAssets: assetsData,\n    }\n  })\n}\n\nconst getSourceAbstractLocation = ({ rootLocation, inputRelativeLocation }) =>\n  resolvePath(rootLocation, inputRelativeLocation)\n\nconst getSourceMapLocation = ({ rootLocation, outputRelativeLocation, outputSourceMapName }) =>\n  resolvePath(rootLocation, path.dirname(outputRelativeLocation), outputSourceMapName)\n\nconst sourceMapKnowsExactLocation = false\n\nconst getSourceMapAbstractpLocation = ({\n  rootLocation,\n  abstractFolderRelativeLocation,\n  inputRelativeLocation,\n  outputSourceMapName,\n}) =>\n  resolvePath(\n    rootLocation,\n    abstractFolderRelativeLocation,\n    path.dirname(inputRelativeLocation),\n    outputSourceMapName,\n  )\n\nconst getFileBranch = ({\n  rootLocation,\n  cacheFolderRelativeLocation,\n  abstractFolderRelativeLocation,\n  filename,\n  compile,\n}) => {\n  const inputRelativeLocation = getInputRelativeLocation({\n    abstractFolderRelativeLocation,\n    filename,\n  })\n\n  const cacheDataLocation = getCacheDataLocation({\n    rootLocation,\n    cacheFolderRelativeLocation,\n    abstractFolderRelativeLocation,\n    filename,\n  })\n\n  return Promise.all([\n    locateFile(inputRelativeLocation, rootLocation),\n    readFile({\n      location: cacheDataLocation,\n      errorHandler: isFileNotFoundError,\n    }).then(({ content, error }) => {\n      if (error) {\n        return {\n          branches: [],\n        }\n      }\n      const cache = JSON.parse(content)\n      if (cache.inputRelativeLocation !== inputRelativeLocation) {\n        throw new Error(\n          `${JSON_FILE} corrupted: unexpected inputRelativeLocation ${\n            cache.inputRelativeLocation\n          }, it must be ${inputRelativeLocation}`,\n        )\n      }\n      return cache\n    }),\n  ])\n    .then(([inputLocation, cache]) => {\n      return {\n        inputLocation,\n        cache,\n      }\n    })\n    .then(({ inputLocation, cache }) => {\n      // here, if readFile returns ENOENT we could/should check is there is something in cache for that file\n      // and take that chance to remove the cached version of that file\n      // but it's not supposed to happen\n      return readFile({\n        location: inputLocation,\n      }).then(({ content }) => {\n        return compile({\n          rootLocation,\n          abstractFolderRelativeLocation,\n          inputRelativeLocation,\n          inputSource: content,\n          filename,\n          getSourceNameForSourceMap: () => {\n            return filename\n          },\n          getSourceLocationForSourceMap: (context) => {\n            const sourceMapUseAbsoluteLocation = true\n\n            if (sourceMapUseAbsoluteLocation) {\n              return `/${context.inputRelativeLocation}`\n            }\n\n            const sourceLocation = getSourceAbstractLocation(context)\n            const sourceMapLocation = sourceMapKnowsExactLocation\n              ? getSourceMapLocation(context)\n              : getSourceMapAbstractpLocation(context)\n            const sourceLocationRelativeToSourceMapLocation = normalizeSeparation(\n              path.relative(path.dirname(sourceMapLocation), sourceLocation),\n            )\n\n            return sourceLocationRelativeToSourceMapLocation\n          },\n        }).then(({ options, generate }) => {\n          const branchIsValid = (branch) => {\n            return JSON.stringify(branch.outputMeta) === JSON.stringify(options)\n          }\n\n          const cachedBranch = cache.branches.find((branch) => branchIsValid(branch))\n\n          return {\n            inputLocation,\n            cache,\n            options,\n            generate,\n            input: content,\n            branch: cachedBranch,\n          }\n        })\n      })\n    })\n}\n\nconst getFileReport = ({\n  rootLocation,\n  cacheFolderRelativeLocation,\n  abstractFolderRelativeLocation,\n  filename,\n  inputETagClient = null,\n  compile,\n}) => {\n  return getFileBranch({\n    rootLocation,\n    cacheFolderRelativeLocation,\n    abstractFolderRelativeLocation,\n    filename,\n    compile,\n  }).then(({ inputLocation, cache, options, generate, input, branch }) => {\n    if (!branch) {\n      return {\n        inputLocation,\n        status: \"missing\",\n        cache,\n        options,\n        generate,\n        branch: {\n          name: cuid(),\n        },\n        input,\n      }\n    }\n\n    return readBranch({\n      rootLocation,\n      cacheFolderRelativeLocation,\n      abstractFolderRelativeLocation,\n      filename,\n      inputLocation,\n      inputETagClient,\n      cache,\n      branch,\n    }).then(({ status, input, output, outputAssets }) => {\n      return {\n        inputLocation,\n        status,\n        cache,\n        options,\n        generate,\n        branch,\n        input,\n        output,\n        outputAssets,\n      }\n    })\n  })\n}\n\nconst updateBranch = ({\n  rootLocation,\n  cacheFolderRelativeLocation,\n  abstractFolderRelativeLocation,\n  filename,\n  inputLocation,\n  status,\n  cache,\n  options,\n  branch,\n  inputETag,\n  output,\n  outputAssets,\n  cacheAutoClean,\n  cacheTrackHit,\n}) => {\n  const { branches } = cache\n  const isCached = status === \"cached\"\n  const isNew = status === \"created\"\n  const isUpdated = status === \"updated\"\n\n  const promises = []\n\n  if (isNew || isUpdated) {\n    const mainLocation = getOutputLocation({\n      rootLocation,\n      cacheFolderRelativeLocation,\n      abstractFolderRelativeLocation,\n      filename,\n      branch,\n    })\n\n    promises.push(\n      writeFileFromString(mainLocation, output),\n      ...outputAssets.map((asset) => {\n        const assetLocation = getOutputAssetLocation({\n          rootLocation,\n          cacheFolderRelativeLocation,\n          abstractFolderRelativeLocation,\n          filename,\n          branch,\n          asset,\n        })\n\n        return writeFileFromString(assetLocation, asset.content)\n      }),\n    )\n  }\n\n  if (isNew || isUpdated || (isCached && cacheTrackHit)) {\n    if (cacheAutoClean) {\n      if (inputETag !== cache.inputETag) {\n        const branchesToRemove = branches.slice()\n\n        // no need to remove the updated branch\n        const index = branchesToRemove.indexOf(branch)\n        branchesToRemove.splice(index, 1)\n\n        branches.length = 0\n        branchesToRemove.forEach((branch) => {\n          const branchLocation = getBranchLocation({\n            rootLocation,\n            cacheFolderRelativeLocation,\n            abstractFolderRelativeLocation,\n            filename,\n            branch,\n          })\n          console.log(`file changed, remove ${branchLocation}`)\n          // the line below is async but non blocking\n          removeFolderDeep(branchLocation)\n        })\n      }\n    }\n\n    if (isNew) {\n      branches.push(branch)\n    }\n\n    const updatedBranches = branches\n      .map((branchToUpdate) => {\n        if (branchToUpdate.name !== branch.name) {\n          return { ...branchToUpdate }\n        }\n        if (isCached) {\n          return {\n            ...branchToUpdate,\n            matchCount: branch.matchCount + 1,\n            lastMatchMs: Number(Date.now()),\n          }\n        }\n        if (isUpdated) {\n          return {\n            ...branchToUpdate,\n            matchCount: branch.matchCount + 1,\n            lastMatchMs: Number(Date.now()),\n            lastModifiedMs: Number(Date.now()),\n            outputAssets: outputAssets.map(({ name, content }) => {\n              return { name, eTag: createETag(content) }\n            }),\n          }\n        }\n        // new branch\n        return {\n          name: branch.name,\n          matchCount: 1,\n          createdMs: Number(Date.now()),\n          lastModifiedMs: Number(Date.now()),\n          lastMatchMs: Number(Date.now()),\n          outputMeta: options,\n          outputAssets: outputAssets.map(({ name, content }) => {\n            return { name, eTag: createETag(content) }\n          }),\n        }\n      })\n      .sort(compareBranch)\n\n    const inputRelativeLocation = getInputRelativeLocation({\n      abstractFolderRelativeLocation,\n      filename,\n    })\n\n    const updatedCache = {\n      inputRelativeLocation,\n      inputETag: isCached ? cache.inputETag : inputETag,\n      inputLocation:\n        inputLocation === resolvePath(rootLocation, inputRelativeLocation)\n          ? undefined\n          : inputLocation,\n      branches: updatedBranches,\n    }\n\n    const cacheDataLocation = getCacheDataLocation({\n      rootLocation,\n      cacheFolderRelativeLocation,\n      abstractFolderRelativeLocation,\n      filename,\n    })\n\n    promises.push(writeFileFromString(cacheDataLocation, JSON.stringify(updatedCache, null, \"  \")))\n  }\n\n  return Promise.all(promises)\n}\n\nconst getFileCompiled = ({\n  rootLocation,\n  cacheFolderRelativeLocation,\n  abstractFolderRelativeLocation,\n  filename,\n  compile,\n  inputETagClient,\n  cacheEnabled,\n  cacheAutoClean,\n  cacheTrackHit,\n}) => {\n  const fileLock = lockForRessource(\n    getCacheDataLocation({\n      rootLocation,\n      cacheFolderRelativeLocation,\n      abstractFolderRelativeLocation,\n      filename,\n    }),\n  )\n\n  return fileLock.chain(() => {\n    return getFileReport({\n      rootLocation,\n      cacheFolderRelativeLocation,\n      abstractFolderRelativeLocation,\n      filename,\n      compile,\n      inputETagClient,\n    })\n      .then(\n        ({\n          inputLocation,\n          status,\n          cache,\n          options,\n          generate,\n          branch,\n          input,\n          inputETag,\n          output,\n          outputAssets,\n        }) => {\n          if (cacheEnabled === false) {\n            status = \"missing\"\n          }\n\n          const outputRelativeLocation = getOutputRelativeLocation({\n            cacheFolderRelativeLocation,\n            abstractFolderRelativeLocation,\n            filename,\n            branch,\n          })\n\n          if (status === \"valid\") {\n            return {\n              inputLocation,\n              status: \"cached\",\n              cache,\n              options,\n              branch,\n              input,\n              inputETag,\n              outputRelativeLocation,\n              output,\n              outputAssets,\n            }\n          }\n\n          return Promise.resolve(generate({ outputRelativeLocation })).then(\n            ({ output, outputAssets }) => {\n              return {\n                inputLocation,\n                status: status === \"missing\" ? \"created\" : \"updated\",\n                cache,\n                options,\n                branch,\n                input,\n                inputETag: createETag(input),\n                outputRelativeLocation,\n                output,\n                outputAssets,\n              }\n            },\n          )\n        },\n      )\n      .then(\n        ({\n          inputLocation,\n          status,\n          cache,\n          options,\n          branch,\n          input,\n          inputETag,\n          outputRelativeLocation,\n          output,\n          outputAssets,\n        }) => {\n          return updateBranch({\n            rootLocation,\n            cacheFolderRelativeLocation,\n            abstractFolderRelativeLocation,\n            filename,\n            inputLocation,\n            status,\n            cache,\n            options,\n            branch,\n            input,\n            inputETag,\n            output,\n            outputAssets,\n            cacheTrackHit,\n            cacheAutoClean,\n          }).then(() => {\n            return {\n              status,\n              inputETag,\n              output,\n              outputRelativeLocation,\n            }\n          })\n        },\n      )\n  })\n}\n\nexport const createCompileService = ({\n  rootLocation,\n  cacheFolderRelativeLocation = \"build\",\n  abstractFolderRelativeLocation = \"compiled\",\n  compile = createCompile(),\n  cacheEnabled = false,\n  cacheAutoClean = true,\n  cacheTrackHit = false,\n}) => {\n  const fileService = createFileService()\n\n  const service = ({ method, url, headers }) => {\n    const pathname = url.pathname\n    // '/compiled/folder/file.js' -> 'compiled/folder/file.js'\n    const filename = pathname.slice(1)\n\n    // je crois, que, normalement\n    // il faudrait \"aider\" le browser pour que tout ça ait du sens\n    // genre lui envoyer une redirection vers le fichier en cache\n    // genre renvoyer 201 vers le cache lorsqu'il a été update ou créé\n    // https://developer.mozilla.org/fr/docs/Web/HTTP/Status/201\n    // renvoyer 302 ou 307 lorsque le cache existe\n    // l'intérêt c'est que si jamais le browser fait une requête vers le cache\n    // il sait à quoi ça correspond vraiment\n    // par contre ça fait 2 requête http\n\n    if (filename.endsWith(\".map\")) {\n      const fileLock = lockForRessource(\n        getCacheDataLocation({\n          rootLocation,\n          cacheFolderRelativeLocation,\n          abstractFolderRelativeLocation,\n          filename,\n        }),\n      )\n\n      return fileLock.chain(() => {\n        const script = filename.slice(0, -4) // 'folder/file.js.map' -> 'folder.file.js'\n\n        // if we receive something like compiled/folder/file.js.map\n        // we redirect to build/folder/file.js/jqjcijjojio/file.js.map\n\n        return getFileBranch({\n          rootLocation,\n          cacheFolderRelativeLocation,\n          abstractFolderRelativeLocation,\n          filename: script,\n          compile,\n        }).then(\n          ({ branch }) => {\n            if (!branch) {\n              return {\n                status: 404,\n              }\n            }\n\n            const scriptCompiledFolder = resolvePath(\n              rootLocation,\n              getBranchRelativeLocation({\n                cacheFolderRelativeLocation,\n                abstractFolderRelativeLocation,\n                filename: script,\n                branch,\n              }),\n            )\n\n            return fileService({\n              method,\n              url: new URL(\n                `file:///${scriptCompiledFolder}/${path.basename(filename)}${url.search}`,\n              ),\n              headers,\n            })\n          },\n          (error) => {\n            if (error && error.reason === \"Unexpected directory operation\") {\n              return {\n                status: 403,\n              }\n            }\n            return Promise.reject(error)\n          },\n        )\n      })\n    }\n\n    return getFileCompiled({\n      rootLocation,\n      cacheFolderRelativeLocation,\n      abstractFolderRelativeLocation,\n      filename,\n      compile,\n      inputETagClient: headers.has(\"if-none-match\") ? headers.get(\"if-none-match\") : undefined,\n      cacheEnabled,\n      cacheAutoClean,\n      cacheTrackHit,\n    }).then(\n      ({ status, inputETag, outputRelativeLocation, output }) => {\n        // here status can be \"created\", \"updated\", \"cached\"\n\n        // c'est un peu optimiste ici de se dire que si c'est cached et qu'on a\n        // if-none-match c'est forcément le etag du client qui a match\n        // faudra changer ça non?\n        if (headers.has(\"if-none-match\") && status === \"cached\") {\n          return {\n            status: 304,\n            headers: {\n              \"cache-control\": \"no-store\",\n              \"x-location\": outputRelativeLocation,\n            },\n          }\n        }\n\n        return {\n          status: 200,\n          headers: {\n            Etag: inputETag,\n            \"content-length\": Buffer.byteLength(output),\n            \"content-type\": \"application/javascript\",\n            \"cache-control\": \"no-store\",\n            \"x-location\": outputRelativeLocation,\n          },\n          body: output,\n        }\n      },\n      (error) => {\n        if (error && error.reason === \"Unexpected directory operation\") {\n          return {\n            status: 403,\n          }\n        }\n        return Promise.reject(error)\n      },\n    )\n  }\n\n  const compileFile = (relativeLocation) =>\n    getFileCompiled({\n      rootLocation,\n      cacheFolderRelativeLocation,\n      abstractFolderRelativeLocation,\n      filename: `${abstractFolderRelativeLocation}/${relativeLocation}`,\n      compile,\n      cacheEnabled,\n      cacheAutoClean,\n      cacheTrackHit,\n    })\n\n  return { service, compileFile }\n}\n"
  ]
}