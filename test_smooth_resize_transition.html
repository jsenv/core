<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Test Smooth Resize Transition</title>
    <style>
      body {
        margin: 40px;
        font-family: Arial, sans-serif;
        background: #f5f5f5;
      }

      .controls {
        display: flex;
        margin-bottom: 40px;
        gap: 10px;
      }

      button {
        padding: 10px 20px;
        color: white;
        font-size: 14px;
        background: #007acc;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      button:hover {
        background: #005a99;
      }

      button.active {
        background: #ff6b35;
      }

      /* Structure de transition */
      .transition-container {
        position: relative;

        /* Ces dimensions seront animées */
        width: 200px;
        height: 100px;
        background: white;
        border: 2px dashed #ccc;
        border-radius: 8px;

        transition:
          width 300ms ease,
          height 300ms ease;
        overflow: hidden;
      }

      .content-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;

        /* Transform sera utilisé pour le scaling */
        transform-origin: center;
        transition: transform 300ms ease;
      }

      .content {
        display: flex;
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        padding: 20px;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      /* États des contenus */
      .state-a .content {
        color: white;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }

      .state-b .content {
        color: white;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }

      .content h3 {
        margin: 0 0 10px 0;
        font-size: 18px;
      }

      .content p {
        margin: 0;
        font-size: 14px;
        text-align: center;
        line-height: 1.4;
      }

      /* Debug info */
      .debug-info {
        margin-top: 30px;
        padding: 15px;
        font-size: 12px;
        font-family: monospace;
        background: #f9f9f9;
        border-radius: 4px;
      }

      .debug-info div {
        margin-bottom: 5px;
      }
    </style>
  </head>
  <body>
    <h1>Test de Transition Smooth de Redimensionnement</h1>

    <div class="controls">
      <button id="btn-state-a" class="active">État A (200x100)</button>
      <button id="btn-state-b">État B (400x200)</button>
      <button id="btn-state-c">État C (150x300)</button>
      <button id="btn-reset">Reset (supprime contraintes)</button>
    </div>

    <div class="transition-container" id="container">
      <div class="content-wrapper" id="wrapper">
        <div class="content state-a" id="content">
          <h3>État A</h3>
          <p>
            Petit rectangle avec du texte qui ne doit pas se déformer pendant la
            transition
          </p>
        </div>
      </div>
    </div>

    <div class="debug-info" id="debug">
      <div><strong>Debug Info:</strong></div>
      <div id="container-size">Container: 200px × 100px</div>
      <div id="content-size">Content naturel: -</div>
      <div id="scale-info">Scale: 1</div>
      <div id="state-info">État: A</div>
    </div>

    <script>
      const container = document.getElementById("container");
      const wrapper = document.getElementById("wrapper");
      const content = document.getElementById("content");
      const debug = {
        containerSize: document.getElementById("container-size"),
        contentSize: document.getElementById("content-size"),
        scaleInfo: document.getElementById("scale-info"),
        stateInfo: document.getElementById("state-info"),
      };

      // États possibles
      const states = {
        a: {
          width: 200,
          height: 100,
          contentClass: "state-a",
          title: "État A",
          text: "Petit rectangle avec du texte qui ne doit pas se déformer pendant la transition",
        },
        b: {
          width: 400,
          height: 200,
          contentClass: "state-b",
          title: "État B",
          text: "Rectangle plus grand avec plus de contenu. Ce texte est plus long pour voir comment le contenu s'adapte dans un espace plus grand. La transition doit être fluide.",
        },
        c: {
          width: 150,
          height: 300,
          contentClass: "state-b", // Même style que B
          title: "État C",
          text: "Rectangle haut et étroit. Format portrait pour tester différents ratios d'aspect.",
        },
      };

      let currentState = "a";
      let isTransitioning = false;

      // Mise à jour du debug
      function updateDebugInfo() {
        const containerRect = container.getBoundingClientRect();
        const contentRect = content.getBoundingClientRect();
        const computedStyle = window.getComputedStyle(wrapper);
        const transform = computedStyle.transform;

        let scaleX = 1;
        let scaleY = 1;
        if (transform && transform !== "none") {
          const matrix = transform.match(/matrix\\((.+)\\)/);
          if (matrix) {
            const values = matrix[1].split(", ").map(Number);
            scaleX = values[0];
            scaleY = values[3];
          }
        }

        debug.containerSize.textContent = `Container: ${containerRect.width.toFixed(0)}px × ${containerRect.height.toFixed(0)}px`;
        debug.contentSize.textContent = `Content: ${contentRect.width.toFixed(0)}px × ${contentRect.height.toFixed(0)}px`;
        debug.scaleInfo.textContent = `Scale: ${scaleX.toFixed(3)}, ${scaleY.toFixed(3)}`;
        debug.stateInfo.textContent = `État: ${currentState.toUpperCase()}`;
      }

      // Transition vers un nouvel état
      function transitionTo(newState) {
        if (isTransitioning || newState === currentState) return;

        isTransitioning = true;
        const state = states[newState];

        // 1. Mesurer les dimensions naturelles du contenu actuel
        wrapper.style.transform = "none";
        const currentNaturalWidth = content.offsetWidth;
        const currentNaturalHeight = content.offsetHeight;

        // 2. Changer le contenu
        content.className = `content ${state.contentClass}`;
        content.innerHTML = `
                <h3>${state.title}</h3>
                <p>${state.text}</p>
            `;

        // 3. Mesurer les dimensions naturelles du nouveau contenu
        const newNaturalWidth = content.offsetWidth;
        const newNaturalHeight = content.offsetHeight;

        // 4. Calculer les scales nécessaires
        const currentContainerWidth = container.offsetWidth;
        const currentContainerHeight = container.offsetHeight;

        // Scale pour que le nouveau contenu remplisse le container actuel
        const scaleX = currentContainerWidth / newNaturalWidth;
        const scaleY = currentContainerHeight / newNaturalHeight;

        // 5. Appliquer le scale initial pour que le nouveau contenu s'adapte au container actuel
        wrapper.style.transform = `scale(${scaleX}, ${scaleY})`;

        console.log("Transition:", {
          from: `${currentContainerWidth}x${currentContainerHeight}`,
          to: `${state.width}x${state.height}`,
          currentNatural: `${currentNaturalWidth}x${currentNaturalHeight}`,
          newNatural: `${newNaturalWidth}x${newNaturalHeight}`,
          initialScale: `${scaleX}, ${scaleY}`,
        });

        // 6. Attendre le prochain frame puis animer
        requestAnimationFrame(() => {
          // Animer vers les nouvelles dimensions et scale(1, 1)
          container.style.width = `${state.width}px`;
          container.style.height = `${state.height}px`;
          wrapper.style.transform = "scale(1, 1)";

          // Mettre à jour l'état
          currentState = newState;
          updateActiveButton();
          updateDebugInfo();

          // Marquer la fin de la transition
          setTimeout(() => {
            isTransitioning = false;
          }, 300);
        });
      }

      // Reset - supprime les contraintes
      function reset() {
        container.style.width = "";
        container.style.height = "";
        wrapper.style.transform = "";
        isTransitioning = false;
        updateDebugInfo();
      }

      // Gestion des boutons
      function updateActiveButton() {
        document
          .querySelectorAll("button")
          .forEach((btn) => btn.classList.remove("active"));
        document
          .getElementById(`btn-state-${currentState}`)
          .classList.add("active");
      }

      // Event listeners
      document
        .getElementById("btn-state-a")
        .addEventListener("click", () => transitionTo("a"));
      document
        .getElementById("btn-state-b")
        .addEventListener("click", () => transitionTo("b"));
      document
        .getElementById("btn-state-c")
        .addEventListener("click", () => transitionTo("c"));
      document.getElementById("btn-reset").addEventListener("click", reset);

      // Mise à jour initiale
      updateDebugInfo();

      // Mise à jour du debug en continu
      setInterval(updateDebugInfo, 100);
    </script>
  </body>
</html>
