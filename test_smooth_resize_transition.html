<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Test Smooth Resize Transition</title>
    <style>
      body {
        margin: 40px;
        font-family: Arial, sans-serif;
        background: #f5f5f5;
      }

      .controls {
        display: flex;
        margin-bottom: 40px;
        gap: 10px;
      }

      button {
        padding: 10px 20px;
        color: white;
        font-size: 14px;
        background: #007acc;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      button:hover {
        background: #005a99;
      }

      button.active {
        background: #ff6b35;
      }

      /* État désactivé pendant les transitions */
      button:disabled {
        color: #999;
        background: #ccc;
        opacity: 0.6;
        cursor: not-allowed;
      }

      .rectangle.disabled {
        opacity: 0.5;
        filter: grayscale(50%);
        cursor: not-allowed;
      }

      .controls-disabled {
        opacity: 0.6;
        pointer-events: none;
      }

      /* Rectangles visibles pour cliquer */
      .rectangles-container {
        display: flex;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 20px;
      }

      .rectangle {
        display: flex;
        box-sizing: border-box;
        padding: 20px;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border: 2px solid #ddd;
        border-radius: 8px;
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
        cursor: pointer;
      }

      .rectangle[data-state="a"] {
        width: 100px;
        height: 100px;
        color: white;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }

      .rectangle[data-state="b"] {
        width: 300px;
        height: 150px;
        color: white;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }

      .rectangle[data-state="c"] {
        width: 100px;
        height: 200px;
        color: white;
        background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
      }

      .rectangle h3 {
        margin: 0 0 10px 0;
        font-size: 18px;
      }

      .rectangle p {
        margin: 0;
        font-size: 14px;
        text-align: center;
        line-height: 1.4;
      }

      /* Zone de transition */
      .transition-zone {
        margin-top: 10px;
      }

      .transition-zone h4 {
        margin-top: 10px;
        margin-bottom: 20px;
        color: #333;
      }

      /* Boîte de visualisation pour centrer la zone de transition */
      .transition-viewport {
        position: relative;
        display: flex;
        width: 350px;
        height: 250px;
        margin: 20px 0;
        align-items: center;
        justify-content: center;
        background: #fafafa;
        border: 3px solid #007acc;
        border-radius: 8px;
      }

      .transition-viewport::before {
        position: absolute;
        top: -8px;
        left: 10px;
        padding: 0 8px;
        color: #007acc;
        font-weight: bold;
        font-size: 12px;
        background: #fafafa;
        content: "Zone de visualisation 350x250";
      }

      /* Ghost debug dans la viewport (position absolue pour ne pas impacter le layout) */
      .debug-ghost {
        position: absolute;
        top: 50%;
        left: 50%;
        z-index: 10;
        border-radius: 4px;
        box-shadow: 0 0 0 3px #ff6b35;
        opacity: 0.3;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }

      /* Structure de transition - NOUVELLE APPROCHE */
      .transition-container {
        position: relative;

        /* Dimensions seront définies dynamiquement */
        background: white;
        border: 8px dashed #ccc;
        border-radius: 8px;

        /* Transition sur les dimensions */
        transition:
          width 3s ease,
          height 3s ease;

        /* Overflow hidden pour que le contenu soit coupé pendant la transition */
        overflow: hidden;
      }

      .transition-container.empty {
        display: flex;
        width: 300px;
        height: 80px;
        align-items: center;
        justify-content: center;
        color: #999;
        font-style: italic;
      }

      .content-wrapper {
        /* Simple wrapper qui ne contraint pas les dimensions */
        display: block;
      }

      .content {
        /* Le contenu a des dimensions FIXES - ne s'adapte pas au conteneur */
        display: flex;
        box-sizing: border-box;

        /* Dimensions fixes - seront définies par JavaScript */
        width: auto;
        height: auto;
        padding: 20px;
        flex-shrink: 0; /* Ne rétrécit pas */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
      }

      /* États des contenus - dimensions détectées automatiquement */
      .content.state-empty {
        color: #666;
        font-style: italic;
      }

      .content h3 {
        margin: 0 0 10px 0;
        font-size: 18px;
      }

      .content p {
        margin: 0;
        font-size: 14px;
        text-align: center;
        line-height: 1.4;
      }

      /* Debug info */
      .debug-info {
        margin-top: 30px;
        padding: 15px;
        font-size: 12px;
        font-family: monospace;
        background: #f9f9f9;
        border-radius: 4px;
      }

      .debug-info div {
        margin-bottom: 5px;
      }
    </style>
  </head>
  <body>
    <h1>Test de Transition smooth</h1>

    <!-- Rectangles visibles - cliquer pour transitionner -->
    <div class="rectangles-container">
      <div class="rectangle" data-state="a" id="rect-a">
        <h3>État A</h3>
        <p>Du texte yep</p>
      </div>

      <div class="rectangle" data-state="b" id="rect-b">
        <h3>État B</h3>
        <p>
          Rectangle plus grand avec plus de contenu. Ce texte est plus long pour
          voir comment le contenu s'adapte dans un espace plus grand. La
          transition doit être fluide.
        </p>
      </div>

      <div class="rectangle" data-state="c" id="rect-c">
        <h3>État C</h3>
        <p>Format portrait</p>
      </div>
    </div>

    <!-- Zone de transition -->
    <div class="transition-zone">
      <h4>Zone de transition:</h4>
      <div class="transition-viewport">
        <div class="transition-container" id="container">
          <div class="content-wrapper" id="wrapper">
            <div class="content state-empty" id="content">
              <p>Cliquez sur un rectangle ci-dessus pour voir la transition</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="debug-info" id="debug">
      <div><strong>Debug Info:</strong></div>
      <div id="container-size">Container: 200px × 100px</div>
      <div id="content-size">Content naturel: -</div>
      <div id="scale-info">Scale: 1</div>
      <div id="state-info">État: A</div>
    </div>

    <script>
      const container = document.getElementById("container");

      const debug = {
        containerSize: document.getElementById("container-size"),
        contentSize: document.getElementById("content-size"),
        scaleInfo: document.getElementById("scale-info"),
        stateInfo: document.getElementById("state-info"),
      };

      // Configuration localStorage
      const STORAGE_KEY = "smoothResizeTransition";

      // Fonction pour charger les préférences depuis localStorage
      function loadPreferences() {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (saved) {
            const prefs = JSON.parse(saved);
            return {
              duration: prefs.duration || 3000,
              alignX: prefs.alignX || "center",
              alignY: prefs.alignY || "center",
            };
          }
        } catch (e) {
          console.warn("Erreur lors du chargement des préférences:", e);
        }
        return {
          duration: 3000,
          alignX: "center",
          alignY: "center",
        };
      }

      // Fonction pour sauvegarder les préférences dans localStorage
      function savePreferences() {
        try {
          const prefs = {
            duration: DURATION,
            alignX: contentAlignX,
            alignY: contentAlignY,
          };
          localStorage.setItem(STORAGE_KEY, JSON.stringify(prefs));
          console.log("Préférences sauvegardées:", prefs);
        } catch (e) {
          console.warn("Erreur lors de la sauvegarde des préférences:", e);
        }
      }

      // Charger les préférences au démarrage
      const savedPrefs = loadPreferences();

      let DURATION = savedPrefs.duration; // Durée chargée depuis localStorage
      const VISUAL_DEBUG = true; // Affiche un ghost externe pour debug
      const VISUAL_DEBUG_KEEP_GHOST = true; // Garde le ghost debug après transition

      // Paramètres d'alignement chargés depuis localStorage
      let contentAlignX = savedPrefs.alignX; // "start", "center", "end"
      let contentAlignY = savedPrefs.alignY; // "start", "center", "end"

      // États possibles - dimensions détectées automatiquement
      const states = {
        empty: {
          contentClass: "state-empty",
          content:
            "<p>Cliquez sur un rectangle ci-dessus pour voir la transition</p>",
        },
        a: {
          contentClass: "state-a",
        },
        b: {
          contentClass: "state-b",
        },
        c: {
          contentClass: "state-c",
        },
      };

      let currentState = "empty";
      let isTransitioning = false;
      let debugGhost = null; // Ghost externe pour debug visuel

      // Fonction pour mettre à jour l'état visuel de l'interface selon isTransitioning
      function updateUIState() {
        const rectangles = document.querySelectorAll(".rectangle");
        const controls = document.querySelector(".controls-container");
        const resetButton = document.querySelector("button");

        if (isTransitioning) {
          // Désactiver visuellement les rectangles
          rectangles.forEach((rect) => {
            rect.classList.add("disabled");
            rect.style.pointerEvents = "none";
          });

          // Désactiver les contrôles
          if (controls) {
            controls.classList.add("controls-disabled");
          }

          // Désactiver le bouton reset spécifiquement
          if (resetButton) {
            resetButton.disabled = true;
            resetButton.textContent = "Transition en cours...";
          }

          // Mettre à jour le debug info
          debug.scaleInfo.textContent =
            "⚠️ Transition en cours - Interface désactivée";
        } else {
          // Réactiver visuellement les rectangles
          rectangles.forEach((rect) => {
            rect.classList.remove("disabled");
            rect.style.pointerEvents = "auto";
          });

          // Réactiver les contrôles
          if (controls) {
            controls.classList.remove("controls-disabled");
          }

          // Réactiver le bouton reset
          if (resetButton) {
            resetButton.disabled = false;
            resetButton.textContent = "Vider la zone";
          }

          // Restaurer le debug info normal
          debug.scaleInfo.textContent = `Clone utilisé: ${isTransitioning ? "Oui" : "Non"}`;
        }

        console.log(`État UI mis à jour: isTransitioning=${isTransitioning}`);
      }

      // Fonction pour mettre à jour l'alignement de la viewport
      function updateAlignment() {
        const viewport = document.querySelector(".transition-viewport");

        // Convertir les valeurs d'alignement en propriétés CSS flexbox
        const alignMap = {
          start: "flex-start",
          center: "center",
          end: "flex-end",
        };

        viewport.style.justifyContent = alignMap[contentAlignX] || "center";
        viewport.style.alignItems = alignMap[contentAlignY] || "center";

        // Mettre à jour le positionnement du ghost debug
        updateGhostPosition();

        console.log(
          `Alignement mis à jour: X=${contentAlignX}, Y=${contentAlignY}`,
        );
      }

      // Fonction pour mettre à jour la position du ghost debug
      function updateGhostPosition() {
        if (!debugGhost) return;

        const positionMap = {
          start: "0%",
          center: "50%",
          end: "100%",
        };

        const transformMap = {
          start: "0%",
          center: "-50%",
          end: "-100%",
        };

        debugGhost.style.marginLeft = contentAlignX === "center" ? 0 : "8px"; // transition container border size
        debugGhost.style.marginTop = contentAlignY === "center" ? 0 : "8px"; // transition container border size
        debugGhost.style.left = positionMap[contentAlignX] || "50%";
        debugGhost.style.top = positionMap[contentAlignY] || "50%";
        debugGhost.style.transform = `translate(${transformMap[contentAlignX] || "-50%"}, ${transformMap[contentAlignY] || "-50%"})`;
      }

      // Détection automatique des dimensions d'un rectangle OU du contenu actuel
      function getDimensions(elementId) {
        let element;

        if (elementId === "current-content") {
          // Cas spécial : mesurer le contenu actuel dans le wrapper
          const wrapper = document.getElementById("wrapper");
          element = wrapper ? wrapper.firstElementChild : null;
        } else {
          // Cas normal : mesurer un rectangle source
          element = document.getElementById(elementId);
        }

        if (!element) {
          console.warn(`Élément ${elementId} non trouvé`);
          return { width: 200, height: 100 }; // fallback
        }

        const rect = element.getBoundingClientRect();
        const dimensions = {
          width: rect.width,
          height: rect.height,
        };

        console.log(`Dimensions détectées pour ${elementId}:`, dimensions);
        return dimensions;
      }

      // Mise à jour du debug
      function updateDebugInfo() {
        const containerRect = container.getBoundingClientRect();

        // Chercher le contenu actuel dans le wrapper
        const wrapper = document.getElementById("wrapper");
        const actualContent = wrapper ? wrapper.firstElementChild : null;
        const contentRect = actualContent
          ? actualContent.getBoundingClientRect()
          : { width: 0, height: 0 };

        debug.containerSize.textContent = `Container: ${containerRect.width.toFixed(0)}px × ${containerRect.height.toFixed(0)}px`;
        debug.contentSize.textContent = `Content: ${contentRect.width.toFixed(0)}px × ${contentRect.height.toFixed(0)}px`;
        debug.scaleInfo.textContent = `Clone utilisé: ${isTransitioning ? "Oui" : "Non"}`;
        debug.stateInfo.textContent = `État: ${currentState.toUpperCase()}`;
      }

      // Fonction de clonage pour la zone de transition (interne)
      function cloneRectangleForTransition(sourceElement) {
        const clone = sourceElement.cloneNode(true);

        // Préparer le clone pour la zone de transition
        clone.style.position = "static"; // Pas de positionnement absolu dans la zone
        clone.style.zIndex = "auto";
        clone.style.pointerEvents = "none"; // Désactiver les interactions

        // Supprimer les transitions du clone pour éviter les conflits
        clone.style.transition = "none";

        // S'assurer que les dimensions sont préservées
        const sourceRect = sourceElement.getBoundingClientRect();
        clone.style.width = `${sourceRect.width}px`;
        clone.style.height = `${sourceRect.height}px`;
        clone.style.flexShrink = "0"; // Ne pas rétrécir

        console.log("Clone interne créé:", {
          original: sourceElement.id,
          dimensions: `${sourceRect.width}x${sourceRect.height}`,
        });

        return clone;
      }

      // Fonction de création du ghost pour debug visuel (dans la viewport)
      function createDebugGhost(sourceElement) {
        const ghost = sourceElement.cloneNode(true);

        // Utiliser la classe CSS dédiée
        ghost.classList.add("debug-ghost");

        // S'assurer que les dimensions sont préservées
        const sourceRect = sourceElement.getBoundingClientRect();
        ghost.style.width = `${sourceRect.width}px`;
        ghost.style.height = `${sourceRect.height}px`;

        console.log("Ghost debug créé:", {
          original: sourceElement.id,
          dimensions: `${sourceRect.width}x${sourceRect.height}`,
        });

        return ghost;
      }

      // Transition vers un nouvel état avec cloneNode
      function transitionTo(newState, sourceRectangle) {
        if (isTransitioning) {
          console.log("Transition déjà en cours, ignorée");
          return;
        }

        isTransitioning = true;

        // Détecter les dimensions actuelles et cibles
        const currentDimensions = getDimensions("current-content");
        const targetDimensions = getDimensions(sourceRectangle.id);

        console.log("Début transition:", {
          from: currentState,
          to: newState,
          currentDimensions,
          targetDimensions,
          sourceElement: sourceRectangle.id,
        });

        // 1. Créer un clone AVANT de désactiver visuellement l'interface
        const clone = cloneRectangleForTransition(sourceRectangle);

        // 2. Créer un ghost debug AVANT de désactiver visuellement (si VISUAL_DEBUG est activé)
        if (VISUAL_DEBUG) {
          // Nettoyer le ghost debug précédent
          if (debugGhost && debugGhost.parentNode) {
            debugGhost.parentNode.removeChild(debugGhost);
            console.log("Ghost debug précédent supprimé");
          }

          debugGhost = createDebugGhost(sourceRectangle);
        }

        // 3. MAINTENANT désactiver visuellement l'interface (après clonage)
        updateUIState();

        // 4. Définir les dimensions actuelles du container (point de départ)
        container.style.transition = `width ${DURATION}ms ease, height ${DURATION}ms ease`;
        container.style.width = `${currentDimensions.width}px`;
        container.style.height = `${currentDimensions.height}px`;

        // 5. Placer le ghost debug dans la viewport (si créé)
        if (VISUAL_DEBUG && debugGhost) {
          const viewport = document.querySelector(".transition-viewport");
          viewport.appendChild(debugGhost);

          // Positionner correctement le ghost selon l'alignement actuel
          updateGhostPosition();

          console.log("Ghost debug placé et positionné dans la viewport");
        }

        // 6. Remplacer le contenu actuel par le clone
        const wrapper = document.getElementById("wrapper");
        if (!wrapper) {
          console.error("Wrapper non trouvé");
          return;
        }
        wrapper.innerHTML = ""; // Vider le wrapper
        wrapper.appendChild(clone); // Ajouter le clone

        // 6bis. Appliquer immédiatement l'alignement au contenu
        // Le contenu doit être à sa position finale même si le container change de taille
        updateAlignment();

        console.log(
          "Clone placé dans la zone de transition avec alignement correct",
        );

        // 7. Forcer un reflow pour stabiliser les dimensions
        const FORCE_REFLOW = clone.offsetHeight;

        // 8. Démarrer l'animation du conteneur vers les dimensions cibles
        setTimeout(() => {
          container.style.width = `${targetDimensions.width}px`;
          container.style.height = `${targetDimensions.height}px`;
        }, 50);

        // 9. Nettoyer le ghost debug après la transition (si nécessaire)
        setTimeout(() => {
          if (
            VISUAL_DEBUG &&
            !VISUAL_DEBUG_KEEP_GHOST &&
            debugGhost &&
            debugGhost.parentNode
          ) {
            debugGhost.parentNode.removeChild(debugGhost);
            debugGhost = null;
            console.log("Ghost debug supprimé après transition");
          } else if (VISUAL_DEBUG && VISUAL_DEBUG_KEEP_GHOST) {
            console.log("Ghost debug conservé pour inspection");
          }

          isTransitioning = false;
          updateUIState(); // Réactiver l'interface visuellement
          console.log("Transition terminée");
        }, DURATION + 100);

        // 10. Mettre à jour l'état
        currentState = newState;
        updateDebugInfo();
      }

      // Retour à l'état vide
      function resetToEmpty() {
        if (isTransitioning) return;

        const emptyState = states.empty;

        // Mesurer les dimensions actuelles
        const currentDimensions = getDimensions("current-content");

        // Définir le point de départ
        container.style.transition = `width ${DURATION}ms ease, height ${DURATION}ms ease`;
        container.style.width = `${currentDimensions.width}px`;
        container.style.height = `${currentDimensions.height}px`;

        // Changer le contenu - recréer l'élément original
        const wrapper = document.getElementById("wrapper");
        const emptyElement = document.createElement("div");
        emptyElement.className = `content ${emptyState.contentClass}`;
        emptyElement.innerHTML = emptyState.content;

        // Remplacer le contenu actuel
        wrapper.innerHTML = "";
        wrapper.appendChild(emptyElement);

        // Appliquer l'alignement immédiatement
        updateAlignment();

        // Mesurer les nouvelles dimensions et animer
        const targetDimensions = getDimensions("current-content");

        setTimeout(() => {
          container.style.width = `${targetDimensions.width}px`;
          container.style.height = `${targetDimensions.height}px`;
        }, 50);

        currentState = "empty";
        updateDebugInfo();

        console.log("Retour à l'état vide");
      }

      // Gestion des clics sur les rectangles
      function setupRectangleClickHandlers() {
        const rectangles = document.querySelectorAll(".rectangle");

        rectangles.forEach((rectangle) => {
          rectangle.addEventListener("click", () => {
            const targetState = rectangle.dataset.state;
            console.log(`Clic sur rectangle ${targetState}:`, rectangle);

            // Déclencher la transition avec le rectangle source
            transitionTo(targetState, rectangle);
          });

          // Debug info au survol
          rectangle.addEventListener("mouseenter", () => {
            const state = rectangle.dataset.state;
            console.log(`Survol rectangle ${state}:`, {
              dimensions: `${rectangle.offsetWidth}x${rectangle.offsetHeight}`,
              element: rectangle,
            });
          });
        });
      }

      // Contrôles (bouton de reset + durée + alignement)
      function addControls() {
        const controlsContainer = document.createElement("div");
        controlsContainer.className = "controls-container";
        controlsContainer.style.display = "flex";
        controlsContainer.style.flexWrap = "wrap";
        controlsContainer.style.alignItems = "center";
        controlsContainer.style.gap = "15px";
        controlsContainer.style.marginTop = "15px";

        // Bouton de reset
        const resetButton = document.createElement("button");
        resetButton.textContent = "Vider la zone";
        resetButton.addEventListener("click", resetToEmpty);

        // Contrôle de durée
        const durationControl = createDurationControl();

        // Contrôles d'alignement
        const alignmentControls = createAlignmentControls();

        controlsContainer.appendChild(resetButton);
        controlsContainer.appendChild(durationControl);
        controlsContainer.appendChild(alignmentControls);

        const transitionZone = document.querySelector(".transition-zone");
        transitionZone.appendChild(controlsContainer);
      }

      // Fonction pour créer le contrôle de durée
      function createDurationControl() {
        const durationLabel = document.createElement("label");
        durationLabel.style.display = "flex";
        durationLabel.style.alignItems = "center";
        durationLabel.style.gap = "8px";
        durationLabel.style.fontSize = "14px";
        durationLabel.style.color = "#333";

        const durationText = document.createElement("span");
        durationText.textContent = "Durée:";

        const durationSlider = document.createElement("input");
        durationSlider.type = "range";
        durationSlider.min = "500";
        durationSlider.max = "5000";
        durationSlider.value = DURATION;
        durationSlider.step = "100";
        durationSlider.style.width = "120px";

        const durationValue = document.createElement("span");
        durationValue.textContent = `${DURATION}ms`;
        durationValue.style.fontWeight = "bold";
        durationValue.style.minWidth = "50px";

        // Mise à jour de la durée
        durationSlider.addEventListener("input", (e) => {
          DURATION = parseInt(e.target.value);
          durationValue.textContent = `${DURATION}ms`;
          savePreferences(); // Sauvegarder la durée
          console.log(
            `Durée de transition mise à jour et sauvegardée: ${DURATION}ms`,
          );
        });

        durationLabel.appendChild(durationText);
        durationLabel.appendChild(durationSlider);
        durationLabel.appendChild(durationValue);

        return durationLabel;
      }

      // Fonction pour créer les contrôles d'alignement
      function createAlignmentControls() {
        const alignmentContainer = document.createElement("div");
        alignmentContainer.style.display = "flex";
        alignmentContainer.style.gap = "10px";
        alignmentContainer.style.alignItems = "center";
        alignmentContainer.style.fontSize = "14px";
        alignmentContainer.style.color = "#333";

        // Contrôle Align X
        const alignXLabel = document.createElement("label");
        alignXLabel.style.display = "flex";
        alignXLabel.style.alignItems = "center";
        alignXLabel.style.gap = "5px";

        const alignXText = document.createElement("span");
        alignXText.textContent = "X:";

        const alignXSelect = document.createElement("select");
        ["start", "center", "end"].forEach((value) => {
          const option = document.createElement("option");
          option.value = value;
          option.textContent = value;
          option.selected = value === contentAlignX;
          alignXSelect.appendChild(option);
        });

        alignXSelect.addEventListener("change", (e) => {
          contentAlignX = e.target.value;
          updateAlignment(); // updateAlignment() sauvegarde automatiquement
        });

        alignXLabel.appendChild(alignXText);
        alignXLabel.appendChild(alignXSelect);

        // Contrôle Align Y
        const alignYLabel = document.createElement("label");
        alignYLabel.style.display = "flex";
        alignYLabel.style.alignItems = "center";
        alignYLabel.style.gap = "5px";

        const alignYText = document.createElement("span");
        alignYText.textContent = "Y:";

        const alignYSelect = document.createElement("select");
        ["start", "center", "end"].forEach((value) => {
          const option = document.createElement("option");
          option.value = value;
          option.textContent = value;
          option.selected = value === contentAlignY;
          alignYSelect.appendChild(option);
        });

        alignYSelect.addEventListener("change", (e) => {
          contentAlignY = e.target.value;
          updateAlignment(); // updateAlignment() sauvegarde automatiquement
        });

        alignYLabel.appendChild(alignYText);
        alignYLabel.appendChild(alignYSelect);

        alignmentContainer.appendChild(alignXLabel);
        alignmentContainer.appendChild(alignYLabel);

        return alignmentContainer;
      }

      // Initialisation
      function init() {
        setupRectangleClickHandlers();
        addControls();
        updateAlignment(); // Appliquer l'alignement initial
        updateUIState(); // Appliquer l'état initial de l'UI
        updateDebugInfo();

        // Mise à jour du debug en continu
        setInterval(updateDebugInfo, 200);

        console.log(
          "Interface initialisée - cliquez sur les rectangles pour transitionner",
        );
      }

      // Lancer l'initialisation quand le DOM est prêt
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    </script>
  </body>
</html>
